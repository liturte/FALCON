{"2815": {"code": ["def power_of_two_numbers(n, e):\n    dp = [[0] * 10 for _ in range(e+1)]\n    dp[0][0] = 1\n\n    for i in range(1, 10):\n        dp[0][i] = 1\n\n    for i in range(1, e+1):\n        dp[i][0] = dp[i-1][0] * 2\n        for j in range(1, 10):\n            dp[i][j] = dp[i-1][j] * 2 + dp[i][j-1]\n\n    dp2 = [0] * (n+1)\n    dp2[0] = 1\n\n    for i in range(1, n+1):\n        dp2[i] = dp2[i-1] * 2\n        if i >= 10:\n            d", "import sys\n\ndef count_numbers(n, e):\n    # Create a list to store the counts of each digit\n    counts = [0] * 10\n    # Calculate the number of times 2^e appears in the decimal representation of 2^(e+1)\n    power_of_2_in_e = str(2 ** (e + 1))\n    counts[2] = power_of_2_in_e.count('2')\n    # Initialize the dp array\n    dp = [[0] * (e + 2) for _ in range(11)]\n    dp[0][0] = 1\n    # Calculate the dp array\n    for i in range(1, 10):\n        for j in range(e + 1):\n            for k in range(i + 1):\n                dp[i][j] += dp[i - 1][j]\n            if j > 0:\n                d", "def count_numbers(n, e):\n    dp = [[0]*26 for _ in range(19)]\n    dp[0][1<<(ord('2')-ord('0'))] = 1\n    for i in range(1, 19):\n        for j in range(26):\n            for k in range(10):\n                if j>>(ord(str(k))-ord('0'))&1:\n                    dp[i][j] += dp[i-1][j]\n                else:\n                    dp[i][j] += dp[i-1][j^(1<<(ord(str(k))-ord('0')))]\n    cnt = [0]*26\n    for i in range(26):\n        if bin(i).count('1') == 2**e:\n            cnt[i] = 1\n    for _ in range(1, 19):\n        n", "def count_numbers(n, e):\n    # The power of 2\n    power_of_2 = 2 ** e\n\n    # The number of digits in the power of 2\n    num_digits = len(str(power_of_2))\n\n    # The number of valid numbers is the number of digits in the power of 2\n    # times the number of numbers from 0 to n that have num_digits digits\n    num_valid_numbers = num_digits * (n + 1)\n\n    return num_valid_numbers\n\nn, e = map(int, input().split())\nprint(count_numbers(n, e))\n\nThis Python code first calculates the power of 2 and the number of digits in it. It then calculates the number of valid numbers by multiplying the number of digits by the number of numbers from 0 to n that have num_digits digits. This is because each number from", "def solve(n, e):\n    # Convert e to binary\n    e = bin(e)[2:]\n    # Length of e in binary\n    el = len(e)\n    # Length of 2^e in decimal\n    ed = len(str(2**int(e, 2)))\n    # Initialize count\n    count = 0\n    # Iterate over all numbers from 0 to n\n    for i in range(n+1):\n        # Convert i to binary and remove the '0b' prefix\n        ib = bin(i)[2:]\n        # If ib contains e as a substring, increment count\n        if e in ib:\n            count += 1\n    return count\n\n# Read input\nn, e = map(int, input().split())\n# Print solution\nprint(solve(n, e))\n\n\nThis code works by converting the exponent e to binary and then iterating over all numbers from 0 to n. For"], "prompt": "\nQUESTION:\nTheta has been learning about powers of $2$ in school. She notices that some numbers when written out contain powers of $2$ in their digit representation: for instance, $12560$ contains $256$ which is a power of $2$. She has been wondering how many such numbers there are.\n\nCan you write a program that counts how many numbers contain a given power of $2$?\n\n-----Input-----\nThe input consists of a single line with two integers $n$ and $e$ ($0 \\le n \\le 15000000, 0 \\le e \\le 25$).\n\n-----Output-----\nOutput a single integer that is equal to the number of distinct integers $k$ ($0 \\le k \\le n$) whose decimal representation contains the digits of $2^e$ as a substring.\n\n-----Examples-----\nSample Input 1:\n1000000 1\nSample Output 1:\n468559\n\nSample Input 2:\n1000000 5\nSample Output 2:\n49401\nPlease provide the solution as pure code only, without explanations or comments.\n\nANSWER:\n```python\n"}}