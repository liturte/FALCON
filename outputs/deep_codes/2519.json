{"2519": {"code": ["def solve(N, K, P):\n    dp = [[0.0] * (K + 1) for _ in range(K + 1)]\n    dp[0][0] = 0.0\n    for i in range(1, K + 1):\n        dp[i][0] = dp[i - 1][0] + P[N - i]\n        dp[i][i] = dp[i - 1][i - 1] + P[N - i]\n    for i in range(1, K + 1):\n        for j in range(1, i):\n            dp[i][j] = max(dp[i - 1][j - 1] + P[N - i], dp[i - 1][j] + P[N - i", "from sys import stdin\nfrom heapq import nlargest\n\nN, K = map(int, stdin.readline().split())\nP = list(map(int, stdin.readline().split()))\n\nP.sort()\nP = P[::-1]  # Sort the probabilities in descending order\n\nexpected_values = [(i+1) * P[i] / 2 for i in range(N)]\ncumulative_expected_values = [0] * (N+1)\n\nfor i in range(N):\n    cumulative_expected_values[i+1] = cumulative_expected_values[i] + expected_values[i]\n\nmax_expected_value = max(cumulative_expected_values)\n\nfor i in range(K-1, N):", "N, K = map(int, input().split())\np = list(map(int, input().split()))\n\ndp = [[0] * (K + 1) for _ in range(N + 1)]\ns = [[0] * (N + 1) for _ in range(N + 1)]\nfor i in range(1, N + 1):\n    for j in range(1, i + 1):\n        s[i][j] = s[i][j - 1] + p[j - 1]\n\nfor i in range(1, N + 1):\n    dp[i][1] = s[i][i] / i\n\nfor i in range(1, N + 1):\n    dp[i][0] = 0\n\nfor k in range(2, K + 1):", "import sys\nfrom heapq import *\n\ndef solve(n, k, p):\n    p.sort()\n    q = []\n    for i in range(n):\n        heappush(q, -p[i])\n    res = 0\n    for _ in range(k):\n        a = -heappop(q)\n        res += a\n        heappush(q, -(a // 2))\n    return res\n\nn, k = map(int, sys.stdin.readline().split())\np = list(map(int, sys.stdin.readline().split()))\nprint(solve(n, k, p))\n\n\nExplanation:\nThe solution uses a heap to keep track of the maximum value of each dice. We sort the array of dice values and push all the", "from sys import stdin\nfrom heapq import nlargest\n\ndef read_ints():\n    return list(map(int, stdin.readline().split()))\n\nN, K = read_ints()\np = read_ints()\n\np.sort()\n\nprint(sum(p[-K:]) + sum(p[-K-1:-2:-1]))\n\n\nThis solution works by first sorting the list of probabilities `p` in ascending order. Then it calculates the sum of the `K` largest probabilities and the sum of the `K-1` largest probabilities from the end of the list. The expected value of the sum of the numbers shown is the sum of these two sums.\n\nThe reason we sum `K` largest probabilities and `K-1` largest probabilities from the end of the list is that we want to maximize"], "prompt": "\nQUESTION:\nWe have N dice arranged in a line from left to right. The i-th die from the left shows p_i numbers from 1 to p_i with equal probability when thrown.\nWe will choose K adjacent dice, throw each of them independently, and compute the sum of the numbers shown. Find the maximum possible value of the expected value of this sum.\n\n-----Constraints-----\n - 1 \u2264 K \u2264 N \u2264 200000\n - 1 \u2264 p_i \u2264 1000\n - All values in input are integers.\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN K\np_1 ... p_N\n\n-----Output-----\nPrint the maximum possible value of the expected value of the sum of the numbers shown.\nYour output will be considered correct when its absolute or relative error from our answer is at most 10^{-6}.\n\n-----Sample Input-----\n5 3\n1 2 2 4 5\n\n-----Sample Output-----\n7.000000000000\n\nWhen we throw the third, fourth, and fifth dice from the left, the expected value of the sum of the numbers shown is 7. This is the maximum value we can achieve.\nPlease provide the solution as pure code only, without explanations or comments.\n\nANSWER:\n```python\n"}}