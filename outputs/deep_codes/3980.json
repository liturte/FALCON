{"3980": {"code": ["n = int(input())\n\nm = [0] * (n+1)\np = [0] * (n+1)\n\nfor i in range(n+1):\n    m[i] = i ^ (i // 2) ^ (i // 4) ^ (i // 8)\n    p[i] = i\n\np[1::2], p[::2] = p[:n//2], p[n//2:]\n\nprint(sum(m))\nprint(*p)\n\n\nExplanation:\n\nThe code calculates the beauty of each number from 0 to n and stores it in the list `m`. The beauty is calculated by applying the bitwise excluding \"OR\" operation to the number and its halves, fourths, eights, and so", "def max_beauty_permutation(n):\n    if n % 2 == 0:\n        return n*(n+1)//2, ' '.join(str(i) for i in range(n, -1, -2))\n    else:\n        return (n+1)*(n//2)+n+1, ' '.join(str(i) for i in range(n-1, -1, -2))\n\nn = int(input())\nmax_beauty, permutation = max_beauty_permutation(n)\nprint(max_beauty)\nprint(permutation)\n\nIn this code, the function `max_beauty_permutation` takes an integer `n` as input and returns the maximum beauty and the corresponding permutation. The beauty", "def max_beauty(n):\n    if n % 2 == 0:\n        return n*(n+1)//2, ' '.join(str(i) for i in range(n, -1, -2))\n    else:\n        return (n+1)*(n//2), ' '.join(str(i) for i in range(n-1, -1, -2))\n\nn = int(input())\nm, p = max_beauty(n)\nprint(m)\nprint(p)\n\n\nThis solution works by exploiting the fact that the maximum beauty is achieved when the permutation is sorted in descending order for even n and in descending order with one number missing for odd n. The beauty is then calculated by summing the xor operations between the permutation and a", "def max_beauty(n):\n    if n == 0:\n        return 0, [0]\n    if n == 1:\n        return 1, [0, 1]\n    if n == 2:\n        return 3, [0, 2, 1]\n    if n == 3:\n        return 6, [0, 3, 1, 2]\n    if n % 2 == 0:\n        m, p = max_beauty(n - 1)\n        m += n ^ (n - 1)\n        p.insert(1, n)\n        return m, p\n    else:\n        m, p = max_beauty(n - 1)\n        m += (n - 1) ^ n\n        p.insert(n", "def max_beauty(n):\n    if n % 2 == 0:\n        return n*(n+1)//2\n    else:\n        return (n+1)*(n//2) + n//2 + 1\n\ndef max_permutation(n):\n    if n % 2 == 0:\n        return list(range(n+1)) + list(range(n-1, -1, -1))\n    else:\n        return list(range(n, -1, -1)) + list(range(1, n+1))\n\nn = int(input())\nprint(max_beauty(n))\nprint(*max_permutation(n))\n\nIn this code, we first define a function `max_beauty` to calculate the maximum possible beauty for"], "prompt": "\nQUESTION:\nLittle penguin Polo likes permutations. But most of all he likes permutations of integers from 0 to n, inclusive.\n\nFor permutation p = p_0, p_1, ..., p_{n}, Polo has defined its beauty \u2014 number $(0 \\oplus p_{0}) +(1 \\oplus p_{1}) + \\cdots +(n \\oplus p_{n})$.\n\nExpression $x \\oplus y$ means applying the operation of bitwise excluding \"OR\" to numbers x and y. This operation exists in all modern programming languages, for example, in language C++ and Java it is represented as \"^\" and in Pascal \u2014 as \"xor\".\n\nHelp him find among all permutations of integers from 0 to n the permutation with the maximum beauty.\n\n\n-----Input-----\n\nThe single line contains a positive integer n (1 \u2264 n \u2264 10^6).\n\n\n-----Output-----\n\nIn the first line print integer m the maximum possible beauty. In the second line print any permutation of integers from 0 to n with the beauty equal to m.\n\nIf there are several suitable permutations, you are allowed to print any of them.\n\n\n-----Examples-----\nInput\n4\n\nOutput\n20\n0 2 1 4 3\nPlease provide the solution as pure code only, without explanations or comments.\n\nANSWER:\n```python\n"}}