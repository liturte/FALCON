{"4608": {"code": ["def main():\n    n = int(input())\n    a = [0] + [int(input()) for _ in range(n)]\n    visited = [0] * (n + 1)\n    cnt = 0\n    cur = 1\n    while True:\n        if visited[cur]:\n            if cur == 2:\n                print(cnt)\n            else:\n                print(-1)\n            return\n        visited[cur] = 1\n        cnt += 1\n        cur = a[cur]\n\nif __name__ == \"__main__\":\n    main()\n\n\nThis solution works by using a while loop to continuously press buttons. It keeps track of the current button by using", "import sys\nfrom collections import deque\n\ndef solve():\n    N = int(sys.stdin.readline().strip())\n    a = [0] + [int(sys.stdin.readline().strip()) for _ in range(N)]\n    visited = [0] * (N+1)\n    visited[1] = 1\n    q = deque([1])\n    while q:\n        cur = q.popleft()\n        nxt = a[cur]\n        if nxt == 2:\n            print(visited[cur])\n            return\n        if visited[nxt] == 0:\n            visited[nxt] = visited[cur] + 1", "from collections import deque\n\nN = int(input())\na = [int(input()) for _ in range(N)]\n\n# Initialize the visited and parent lists\nvisited = [False] * (N + 1)\nparent = [0] * (N + 1)\n\n# Use BFS to find the shortest path from Button 1 to Button 2\nq = deque([1])\nvisited[1] = True\nwhile q:\n    cur = q.popleft()\n    if cur == 2:\n        # Reconstruct the path from Button 1 to Button 2\n        path = []\n        while cur != 1:\n            path.append(cur)", "from collections import deque\n\ndef solve():\n    N = int(input())\n    a = [int(input()) for _ in range(N)]\n    visited = [False] * (N + 1)\n    queue = deque([(1, 0)])\n    while queue:\n        x, d = queue.popleft()\n        if x == 2:\n            return d\n        if visited[x]:\n            continue\n        visited[x] = True\n        queue.append((a[x-1], d + 1))\n    return -1\n\nprint(solve())\n\n\nThis code uses a Breadth-First Search (BFS) to find the shortest", "from collections import deque\n\ndef main():\n    N = int(input())\n    a = [int(input()) for _ in range(N)]\n    d = deque([(1, 0)])  # (button, presses)\n    seen = [0] * (N+1)\n    seen[1] = 1\n    while d:\n        b, p = d.popleft()\n        for i in a:\n            if i == b:  # if the button we're looking at is the one we're pressing\n                print(p+1)\n                return\n            if not seen[i]:  # if the button we're looking at has not been seen"], "prompt": "\nQUESTION:\nTakahashi wants to gain muscle, and decides to work out at AtCoder Gym.\nThe exercise machine at the gym has N buttons, and exactly one of the buttons is lighten up.\nThese buttons are numbered 1 through N.\nWhen Button i is lighten up and you press it, the light is turned off, and then Button a_i will be lighten up. It is possible that i=a_i.\nWhen Button i is not lighten up, nothing will happen by pressing it.\nInitially, Button 1 is lighten up. Takahashi wants to quit pressing buttons when Button 2 is lighten up.\nDetermine whether this is possible. If the answer is positive, find the minimum number of times he needs to press buttons.\n\n-----Constraints-----\n - 2 \u2264 N \u2264 10^5\n - 1 \u2264 a_i \u2264 N\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN\na_1\na_2\n:\na_N\n\n-----Output-----\nPrint -1 if it is impossible to lighten up Button 2.\nOtherwise, print the minimum number of times we need to press buttons in order to lighten up Button 2.\n\n-----Sample Input-----\n3\n3\n1\n2\n\n-----Sample Output-----\n2\n\nPress Button 1, then Button 3.\nPlease provide the solution as pure code only, without explanations or comments.\n\nANSWER:\n```python\n"}}