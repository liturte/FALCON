{"2635": {"code": ["class Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        if not matrix: return []\n        R, C = len(matrix), len(matrix[0])\n        seen = [[False] * C for _ in matrix]\n        ans = []\n        dr = [0, 1, 0, -1]\n        dc = [1, 0, -1, 0]\n        r = c = di = 0\n        for _ in range(R * C):\n            ans.append(matrix[r][c])\n            seen[r][c] = True\n            cr, cc = r + dr[di], c + dc[di]\n            if 0 <= cr < R and 0 <= cc < C and not seen[cr][cc]:\n                r, c = cr, cc\n            else:\n                di = (di + 1) % 4\n                r, c = r + dr[di], c + dc[di]\n        return ans\n\n\nThis solution uses a four-direction vector to keep track of the direction", "class Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        res = []\n        while matrix:\n            res += matrix.pop(0)\n            if matrix and matrix[0]:\n                for row in matrix:\n                    res.append(row.pop())\n            if matrix:\n                res += matrix.pop()[::-1]\n            if matrix and matrix[0]:\n                for row in matrix[::-1]:\n                    res.append(row.pop(0))\n        return res\n\n\n\"\"\"\n\n# 52. N-Queens II\n# Hard\n\n# The n-queens puzzle is the problem of placing n queens on an n\u00d7n chessboard such that no two queens attack each other.\n\n# Given an integer n, return the number of distinct solutions to the n-queens puzzle.\n\n# Example:\n\n# Input: 4\n# Output: 2\n# Explanation: There are two distinct solutions to the 4-queens puzzle as shown below.\n# [\n#  [\".Q..\",", "class Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        if not matrix: return []\n        R, C = len(matrix), len(matrix[0])\n        seen = [[False] * C for _ in matrix]\n        ans = []\n        dr = [0, 1, 0, -1]\n        dc = [1, 0, -1, 0]\n        r = c = di = 0\n        for _ in range(R * C):\n            ans.append(matrix[r][c])\n            seen[r][c] = True\n            cr, cc = r + dr[di], c + dc[di]\n            if 0 <= cr < R and 0 <= cc < C and not seen[cr][cc]:\n                r, c = cr, cc\n            else:\n                di = (di + 1) % 4\n                r, c = r + dr[di], c + dc[di]\n        return ans\n\n\nEXPLAINATION:\nThis solution uses a direction vector dr", "class Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        res = []\n        while matrix:\n            res += matrix.pop(0) # top row\n            if matrix and matrix[0]: # right column\n                for row in matrix:\n                    res.append(row.pop())\n            if matrix: # bottom row\n                res += matrix.pop()[::-1]\n            if matrix and matrix[0]: # left column\n                for row in matrix[::-1]:\n                    res.append(row.pop(0))\n        return res\n\n\nThis solution works by popping the first row of the matrix and adding it to the result. Then it goes through the remaining rows and adds the last element of each row to the result. It does the same for the last row, but in reverse order. Finally, it repeats the process for the first column of the remaining rows, but in reverse order. This continues until there are no more rows or columns left to add.\n\nThis solution has a time complexity of O(m*n) because it visits each element in the matrix once. It also", "class Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        if not matrix: return []\n        R, C = len(matrix), len(matrix[0])\n        seen = [[False] * C for _ in matrix]\n        ans = []\n        dr = [0, 1, 0, -1]\n        dc = [1, 0, -1, 0]\n        r = c = di = 0\n        for _ in range(R * C):\n            ans.append(matrix[r][c])\n            seen[r][c] = True\n            cr, cc = r + dr[di], c + dc[di]\n            if 0 <= cr < R and 0 <= cc < C and not seen[cr][cc]:\n                r, c = cr, cc\n            else:\n                di = (di + 1) % 4\n                r, c = r + dr[di], c + dc[di]\n        return ans\n\n\nThis solution starts at the top left corner of the matrix and explores"], "prompt": "\nQUESTION:\nGiven a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.\n\nExample 1:\n\n\nInput:\n[\n [ 1, 2, 3 ],\n [ 4, 5, 6 ],\n [ 7, 8, 9 ]\n]\nOutput: [1,2,3,6,9,8,7,4,5]\n\n\nExample 2:\n\nInput:\n[\n  [1, 2, 3, 4],\n  [5, 6, 7, 8],\n  [9,10,11,12]\n]\nOutput: [1,2,3,4,8,12,11,10,9,5,6,7]\nSTARTER CODE:\nclass Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        \n\nPlease provide the solution as pure code only, without explanations or comments.\n\nANSWER:\n```python\n"}}