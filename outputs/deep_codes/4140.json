{"4140": {"code": ["s = input()\nprint(min(sum(i != j for i, j in zip(s, s[1:])), sum(i == j for i, j in zip(s, s[1:]))))\n\n\nEXPLANATION:\nThis code reads a string of 0s and 1s, and then calculates the minimum number of tiles that need to be repainted to satisfy the condition. The condition is that any two adjacent tiles have different colors.\n\nThe `zip(s, s[1:])` function is used to create pairs of adjacent tiles. The `i != j` and `i == j` expressions count the number of pairs where the tiles are the same and different, respectively. The `min` function returns the smaller of these two counts, which is the minimum number of tiles that need to be repainted.\n\nThis solution has a time complexity of O(n), where n is the length of the string.\n\nNote: This solution assumes that the string is inputted without any spaces or newline characters.\n\"\"\"\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    string s;\n    cin >> s;", "S = input()\ncount = 0\nfor i in range(len(S) - 1):\n    if S[i] == S[i+1]:\n        count += 1\nprint(count)\n\nThis Python code reads a string S from the standard input, counts the number of adjacent pairs of tiles that have the same color, and prints the count.\n\nThis solution works because it iterates over the string S, comparing each character to the next one. If the characters are the same, it increments a counter. The final count is the minimum number of tiles that need to be repainted to satisfy the condition.\n\nThe time complexity of this solution is O(n), where n is the length of the string S, because it makes a single pass over the string. The space complexity is O(1), because it only uses a constant amount of extra space to store the input string and the counter.\n\nThis solution assumes that the input string S is a string of 0s and 1s. If the input string might contain other characters, the solution would need to be modified to handle those cases.\n\n\"\"\"\n\n# -----------------------------------\n# Solution:\n# -----------------------------------\n\nS = input()\ncount = 0", "S = input()\ncount = 0\nfor i in range(len(S) - 1):\n    if S[i] == S[i+1]:\n        count += 1\nprint(count)\n\n\nExplanation:\nThe solution is straightforward. We iterate through the string `S` and check if the current character is the same as the next one. If it is, we increment the count of tiles that need to be repainted. Finally, we print the count.\n\nThe time complexity of this solution is O(n), where n is the length of the string `S`, because we're making a single pass through the string. The space complexity is O(1), because we're only using a constant amount of space to store the input string and the count of tiles that need to be repainted.\n\nThis code will read the input string `S`, then iterate through each character in `S`, checking if the current character is the same as the next one. If it is, it increments the `count` variable by 1. Finally, it prints the `count` variable, which represents the minimum number of tiles that need to be repainted.\n\"\"\"\n\n\n# Solution", "S = input()\ncount = 0\nfor i in range(len(S) - 1):\n    if S[i] == S[i+1]:\n        count += 1\nprint(count)\n\n\nEXPLANATION:\nThis solution works by iterating through the string `S`. For each character in the string, it checks if the character is the same as the next one. If they are the same, it increments a counter. The final count is the minimum number of tiles that need to be repainted.\n\nThis solution has a time complexity of O(n), where n is the length of the string `S`, because it only needs to iterate through the string once. It has a space complexity of O(1), because it only uses a single counter variable to keep track of the number of tiles that need to be repainted.\n\nThe output of this solution is the number of tiles that need to be repainted, so there is no need to print anything else.\n\nThis solution assumes that the input is a string of 0s and 1s, as specified in the problem statement. If the input is not in this format, the solution may not work correctly.", "S = input()\n\ncount = 0\nfor i in range(len(S) - 1):\n    if S[i] == S[i+1]:\n        count += 1\n\nprint(count)\n\nThis solution works by iterating over the string, comparing each character with the next one. If they are the same, it increments a counter. The final count is the minimum number of tiles that need to be repainted.\n\nThe time complexity of this solution is O(n), where n is the length of the string. This is because it only needs to iterate over the string once. The space complexity is O(1), as it only uses a constant amount of extra space."], "prompt": "\nQUESTION:\nN tiles are arranged in a row from left to right. The initial color of each tile is represented by a string S of length N.\nThe i-th tile from the left is painted black if the i-th character of S is 0, and painted white if that character is 1.\nYou want to repaint some of the tiles black or white, so that any two adjacent tiles have different colors.\nAt least how many tiles need to be repainted to satisfy the condition?\n\n-----Constraints-----\n - 1 \\leq |S| \\leq 10^5\n - S_i is 0 or 1.\n\n-----Input-----\nInput is given from Standard Input in the following format:\nS\n\n-----Output-----\nPrint the minimum number of tiles that need to be repainted to satisfy the condition.\n\n-----Sample Input-----\n000\n\n-----Sample Output-----\n1\n\nThe condition can be satisfied by repainting the middle tile white.\nPlease provide the solution as pure code only, without explanations or comments.\n\nANSWER:\n```python\n"}}