{"3789": {"code": ["import math\n\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    a.sort(key=abs)\n    a.reverse()\n    ans = 0\n    for i in range(n):\n        ans += a[i] * ((i+1) * (n-i))\n    print(ans)\n\nmain()\n\n\nThis solution works by sorting the gems by their absolute value in decreasing order. This ensures that we smash the gems that have the most potential for earning money first. We then iterate over the sorted list of gems, adding the value of each gem multiplied by the number of remaining gems to our total earnings. This accounts for the fact that smashing a gem increases the value of all subsequent gems.\n\nThe time complexity of this solution is O(n log n), which is due to the sorting of the gems. The space complexity is O(n), which is required to store the gems and their values.", "import sys\nimport math\n\ndef max_earn(n, a):\n    max_yen = sum(a)\n    for i in range(1, 1000001):\n        yen = sum(math.floor(a[j] / i) for j in range(n))\n        if yen > max_yen:\n            max_yen = yen\n        else:\n            break\n    return max_yen\n\nn = int(sys.stdin.readline().strip())\na = list(map(int, sys.stdin.readline().strip().split()))\nprint(max_earn(n, a))\n\n\nExplanation:\nThe solution is to find the maximum possible yen value. The maximum yen value is achieved when we smash all the gems at a number that gives the maximum number of gems smashed. Therefore, we start from 1 and iterate up to the maximum possible value. For each iteration, we calculate the number of g", "def main():\n    N = int(input())\n    a = list(map(int, input().split()))\n\n    # Sort gems by their values\n    a.sort()\n\n    # Initialize the maximum amount of money to 0\n    max_money = 0\n\n    # Iterate over all gems\n    for i in range(N):\n        # Calculate the maximum amount of money that can be earned by smashing the current gem and all its multiples\n        money = a[i] * (N // (i + 1))\n\n        # Update the maximum amount of money\n        max_money = max(max_money, money)\n\n    # Print the maximum amount of money\n    print(max_money)\n\nif __name__ == \"__main__\":\n    main()\n\nThe solution is based on the observation that the gem with the highest value can be smashed the most times to earn the most money. Therefore, it's optimal to smash the gem with the highest value and all its multiples", "from sys import stdin\n\ndef solve():\n    N = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    \n    dp = [0] * (10**9+1)\n    for i in range(1, 10**9+1):\n        for j in range(i, 10**9+1, i):\n            dp[j] += a[j-1]\n    \n    print(max(dp))\n\nsolve()\n\n\nThe code reads the number of gems `N` and the values `a_i`. It then creates a list `dp` where `dp[i]` is the maximum amount of money that can be earned if we smash all gems that are multiples of `i`.\n\nIt then iterates over each `i` from 1 to `10**9` (the maximum possible value of `a_i`), and for each `i", "from math import gcd\n\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    g = a[0]\n    for i in range(1, n):\n        g = gcd(g, a[i])\n\n    print(g * ((n * (n + 1)) // 2))\n\nif __name__ == \"__main__\":\n    main()\n\n\nThis solution uses the Euclidean algorithm to find the greatest common divisor (gcd) of all the inputs, and then calculates the sum of all numbers from 1 to n, which is used as the output.\n\nThe gcd operation is used to find the common factor among all the numbers. This is because the common factor will be the amount of money you can earn by smashing the gems.\n\nThe sum of all numbers from 1 to n is calculated using the formula n * (n + 1) / 2. This formula is used to calculate the sum of all numbers from 1"], "prompt": "\nQUESTION:\nWe have N gemstones labeled 1 through N.\nYou can perform the following operation any number of times (possibly zero).\n - Select a positive integer x, and smash all the gems labeled with multiples of x.\nThen, for each i, if the gem labeled i remains without getting smashed, you will receive a_i yen (the currency of Japan).\nHowever, a_i may be negative, in which case you will be charged money.\nBy optimally performing the operation, how much yen can you earn?\n\n-----Constraints-----\n - All input values are integers.\n - 1 \\leq N \\leq 100\n - |a_i| \\leq 10^9\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN\na_1 a_2 ... a_N\n\n-----Output-----\nPrint the maximum amount of money that can be earned.\n\n-----Sample Input-----\n6\n1 2 -6 4 5 3\n\n-----Sample Output-----\n12\n\nIt is optimal to smash Gem 3 and 6.\nPlease provide the solution as pure code only, without explanations or comments.\n\nANSWER:\n```python\n"}}