{"3186": {"code": ["def solve(N, M, K):\n    mod = 10**6 + 7\n    fact = [0]*(N+1)\n    fact[0] = 1\n    for i in range(1, N+1):\n        fact[i] = (fact[i-1]*i)%mod\n\n    invfact = [0]*(N+1)\n    invfact[N] = pow(fact[N], mod-2, mod)\n    for i in range(N-1, -1, -1):\n        invfact[i] = (invfact[i+1]*(i+1))%mod\n\n    def comb(n, k):\n        if k>n or k<0:\n            return 0\n        return (fact[n]*invfact[k]*invfact[n-k])%mod\n\n    return (comb(N*M, K)*M)%mod\n\nN, M, K = map(int, input().split())\nprint(solve(N, M, K))\n\n\nEXPLANATION:\nThe problem is asking for the number of ways to choose K objects from N objects, each with M copies. This is a combinatorics problem. We can solve it by using the concept of combinations.\n\nFirst, we need to calculate the factorial of N, the factorial of M, and the inverse of the factorial of M", "MOD = 10**6 + 7\n\ndef binom(n, k):\n    if k > n:\n        return 0\n    if k > n - k:\n        k = n - k\n    res = 1\n    for i in range(k):\n        res = res * (n - i) % MOD\n        res = res * pow(i + 1, MOD - 2, MOD)\n    return res\n\nN, M, K = map(int, input().split())\nprint(binom(N * M, K) * pow(M, K, MOD) % MOD)\n\nThis code uses the binomial theorem to calculate the number of ways to choose K objects from N objects with M copies each. It uses the modulo operation to ensure that the result is within the range of 10^6 + 7. The binom function calculates the binomial coefficient, and the pow function is used to calculate the modular inverse.\n\nPlease note that this code assumes that the input is given in the form of \"N M K\". The input is read using the map function and the split method. The binom function is used to calculate the binomial coefficient, and the pow function is used to calculate the modular inverse. The result is printed on the console.", "def solve(N, M, K):\n    MOD = 10**6 + 7\n    fact = [0]*(N+1)\n    inv = [0]*(N+1)\n    fact[0] = fact[1] = inv[0] = inv[1] = 1\n    for i in range(2, N+1):\n        fact[i] = (fact[i-1]*i)%MOD\n        inv[i] = (MOD - MOD//i)*inv[MOD%i]%MOD\n    for i in range(2, N+1):\n        inv[i] = (inv[i-1]*inv[i])%MOD\n    def C(n, k):\n        if k>n or k<0:\n            return 0\n        return fact[n]*inv[k]*inv[n-k]%MOD\n    return C(N*M, K)\n\nN, M, K = map(int, input().split())\nprint(solve(N, M, K))\n\n\nEXPLANATION:\nThis solution uses the combination formula in combinatorics, which is C(n, k) = n!-- / (k!--*(n-k)!--). We calculate the factorial and inverse factorial of all numbers up to n, and then use these to calculate C(n, k). The result is then calculated modulo", "MOD = 10**6+7\n\ndef solve(n, m, k):\n    fact = [0]*(n+1)\n    invfact = [0]*(n+1)\n    fact[0] = invfact[0] = 1\n    for i in range(1, n+1):\n        fact[i] = (fact[i-1]*i)%MOD\n        invfact[i] = fact[i]**(MOD-2)\n    def comb(n, r):\n        if r > n or r < 0:\n            return 0\n        return (fact[n]*invfact[n-r]*invfact[r])%MOD\n    return sum(comb(n*m, k) - comb(n*m, k-m) for n in range(k, n+1))%MOD\n\nn, m, k = map(int, input().split())\nprint(solve(n, m, k))\n\nThis code uses dynamic programming to calculate factorials and combinations, and then uses these to calculate the number of ways to choose exactly $K$ objects from $N$ objects, each with $M$ copies. The result is outputted modulo $10^6+7$ to prevent overflow.\n\nThe code first calculates factorials and their inverses, then uses these to calculate combinations. The sum over all possible values of $n$ from $", "def solve(n, m, k):\n    mod = 10**6 + 7\n    fact = [0]*(n+m+1)\n    factinv = [0]*(n+m+1)\n    fact[0] = factinv[0] = 1\n    for i in range(1, n+m+1):\n        fact[i] = (fact[i-1]*i)%mod\n        factinv[i] = factinv[i-1]*pow(i, mod-2, mod)\n    return (fact[n+m]*factinv[n]*factinv[m])%mod\n\nn, m, k = map(int, input().split())\nprint(solve(n, m, k))\n\n\nEXPLANATION:\nThis problem can be solved by combinatorics. We have N objects and M copies of each object. We need to find the number of ways to take exactly K of them. This is equivalent to finding the number of ways to choose K objects from N+M. We use the formula for combinations in combinatorics which is nCr = nCk * kCk. Here, n = N+M, k = K. We also use the fact that nCr = nC(n-r) to simplify the calculation. The result is given modulo 10^6 + 7 to handle large numbers.\n\nThe python code uses dynamic programming"], "prompt": "\nQUESTION:\nYou have $N$ objects, each with $M$ copies. How many ways are there to take exactly $K$ of them?\n\n-----Input-----\nThe first line of input contains three integers, $N$, $M$ and $K$ respectively, subjected to $1 \\leq N, M, K \\leq 10^5$.\n\n-----Output-----\nOutput the number of ways. As the number of ways could be large, output them modulo $10^6 + 7$.\n\n-----Examples-----\nSample Input 1:\n10 1 2\nSample Output 1:\n45\n\nSample Input 2:\n3 3 3\nSample Output 2:\n10\nPlease provide the solution as pure code only, without explanations or comments.\n\nANSWER:\n```python\n"}}