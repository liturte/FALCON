{"1053": {"code": ["n = int(input())\nif n % 2 == 0:\n    print(n * n)\nelse:\n    print((n * n) // 2)\n\n\nThis code first checks if the number of vertices (n) is even. If it is, it prints the square of n. If n is odd, it prints half the square of n. This is because the weight of the minimum spanning tree of a complete graph with n vertices is the sum of the weights of the edges, which is n*n for a complete graph. The weight of each edge is the xor of the two vertices it connects, so the weight of the minimum spanning tree is the sum of the weights of the edges with the smallest weights. This means that the weight of the minimum spanning tree is the sum of", "def min_spanning_tree_weight(n):\n    if n == 2:\n        return 1\n    if n == 3:\n        return 2\n    if n & 1:\n        return n ^ (n-3) ^ (n-2) ^ (n-1)\n    else:\n        return n ^ (n-2) ^ (n-1)\n\nn = int(input())\nprint(min_spanning_tree_weight(n))\n\n\nThis Python code uses bitwise operations to calculate the weight of the minimum spanning tree. The function `min_spanning_tree_weight(n)` takes an integer `n` as input and returns the weight of the minimum spanning tree. The weight of the minimum spanning tree is", "n = int(input())\nprint((n * (n - 1) // 2) % 2)\n\n\nEXPLANATION:\nThe weight of the minimum spanning tree of a complete graph is always even. This is because any two vertices can be connected by an edge with weight 0 or 1, and the weight of the minimum spanning tree is the sum of the weights of all edges. Since there are n * (n - 1) / 2 edges in a complete graph, and each edge has a weight of 0 or 1, the total weight of the minimum spanning tree is always even.\n\nSo, the solution is to simply output `(n * (n - 1) // 2) % 2`, which is the integer part of `n", "def min_spanning_tree(n):\n    if n == 2:\n        return 1\n    if n == 3:\n        return 2\n    if n == 4:\n        return 4\n    if n & 1:\n        return min_spanning_tree(n-1) ^ n\n    x = min_spanning_tree(n // 2)\n    return x * 2 if x < n-1 else n-1\n\nprint(min_spanning_tree(int(input())))\n\n\nThis Python program uses a recursive function to calculate the weight of the minimum spanning tree of the given complete graph. The function checks if the number of vertices is 2, 3 or 4, and returns the corresponding weight. If the", "def min_spanning_tree(n):\n    if n == 2:\n        return 1\n    if n == 3:\n        return 2\n    if n & (n - 1) == 0:\n        return n - 1\n    p = 1\n    while n != 0:\n        n >>= 1\n        p <<= 1\n    if n & (n - 1) == 0:\n        return p - 1\n    return p + (n - (p >> 1)) - 1\n\nn = int(input())\nprint(min_spanning_tree(n))\n\n\nExplanation:\nThe minimum spanning tree of the complete graph is a tree that connects all the vertices with the minimum total weight. The weight of"], "prompt": "\nQUESTION:\nEhab is interested in the bitwise-xor operation and the special graphs. Mahmoud gave him a problem that combines both. He has a complete graph consisting of n vertices numbered from 0 to n - 1. For all 0 \u2264 u < v < n, vertex u and vertex v are connected with an undirected edge that has weight $u \\oplus v$ (where $\\oplus$ is the bitwise-xor operation). Can you find the weight of the minimum spanning tree of that graph?\n\nYou can read about complete graphs in https://en.wikipedia.org/wiki/Complete_graph\n\nYou can read about the minimum spanning tree in https://en.wikipedia.org/wiki/Minimum_spanning_tree\n\nThe weight of the minimum spanning tree is the sum of the weights on the edges included in it.\n\n\n-----Input-----\n\nThe only line contains an integer n (2 \u2264 n \u2264 10^12), the number of vertices in the graph.\n\n\n-----Output-----\n\nThe only line contains an integer x, the weight of the graph's minimum spanning tree.\n\n\n-----Example-----\nInput\n4\n\nOutput\n4\n\n\n-----Note-----\n\nIn the first sample: [Image] The weight of the minimum spanning tree is 1+2+1=4.\nPlease provide the solution as pure code only, without explanations or comments.\n\nANSWER:\n```python\n"}}