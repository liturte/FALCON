{"558": {"code": ["MOD = 998244353\nN, M, K = map(int, input().split())\ndp = [[0] * (K + 1) for _ in range(N + 1)]\ndp[0][0] = 1\nfor i in range(1, N + 1):\n    for j in range(min(i, K) + 1):\n        dp[i][j] = (dp[i - 1][j] * max(M, j) + (dp[i - 1][j - 1] if j else 0) * max(M, j - 1)) % MOD\nprint(sum(dp[N]) % MOD)\n\n\nExplanation:\nThis solution uses dynamic programming. The state of the dynamic programming is dp[i][j], where i is the number of", "MOD = 998244353\nN, M, K = map(int, input().split())\ndp = [[0] * (K + 1) for _ in range(N + 1)]\ndp[0][0] = 1\nfor i in range(N):\n    for j in range(min(i + 1, K) + 1):\n        dp[i + 1][j] = (dp[i + 1][j] + dp[i][j] * max(0, j - i) * M) % MOD\n        if j > 0:\n            dp[i + 1][j] = (dp[i + 1][j] + dp[i][j - 1] * M) % MOD\n        if i + 2 <= N and j + 1 <= K:\n            dp[i", "MOD = 998244353\nN, M, K = map(int, input().split())\n\ndp = [[0] * (K + 1) for _ in range(N + 1)]\ndp[0][0] = 1\n\nfor i in range(1, N + 1):\n    for j in range(i + 1):\n        if j > 0:\n            dp[i][j] = (dp[i][j] + dp[i - 1][j - 1] * M) % MOD\n        if j < i:\n            dp[i][j] = (dp[i][j] + dp[i - 1][j] * (M - 1)) % MOD\n        if j < i - 1:\n            dp[i][j] = (dp", "MOD = 998244353\nN, M, K = map(int, input().split())\n\nfact = [0] * (N + 1)\nfactinv = [0] * (N + 1)\nfact[0] = factinv[0] = 1\nfor i in range(1, N + 1):\n    fact[i] = (fact[i - 1] * i) % MOD\n    factinv[i] = factinv[i - 1] * pow(i, MOD - 2, MOD)\n\ndef comb(n, k):\n    return fact[n] * factinv[k] * factinv[n - k] % MOD\n\ndef solve(n, m, k):\n    if m < k: return 0\n    if n == 0: return 1", "MOD = 998244353\nN, M, K = map(int, input().split())\n\nfact = [1] * (N + 1)\nfor i in range(1, N + 1):\n    fact[i] = (fact[i - 1] * i) % MOD\n\ninvfact = [1] * (N + 1)\ninvfact[N] = pow(fact[N], MOD - 2, MOD)\nfor i in range(N, 0, -1):\n    invfact[i - 1] = (invfact[i] * i) % MOD\n\ndef ncr(n, r):\n    if r < 0 or n < r:\n        return 0\n    return (fact[n] * invfact[r] * invfact[n - r"], "prompt": "\nQUESTION:\nThere are N blocks arranged in a row. Let us paint these blocks.\nWe will consider two ways to paint the blocks different if and only if there is a block painted in different colors in those two ways.\nFind the number of ways to paint the blocks under the following conditions:\n - For each block, use one of the M colors, Color 1 through Color M, to paint it. It is not mandatory to use all the colors.\n - There may be at most K pairs of adjacent blocks that are painted in the same color.\nSince the count may be enormous, print it modulo 998244353.\n\n-----Constraints-----\n - All values in input are integers.\n - 1 \\leq N, M \\leq 2 \\times 10^5\n - 0 \\leq K \\leq N - 1\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN M K\n\n-----Output-----\nPrint the answer.\n\n-----Sample Input-----\n3 2 1\n\n-----Sample Output-----\n6\n\nThe following ways to paint the blocks satisfy the conditions: 112, 121, 122, 211, 212, and 221. Here, digits represent the colors of the blocks.\nPlease provide the solution as pure code only, without explanations or comments.\n\nANSWER:\n```python\n"}}