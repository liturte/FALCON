{"2582": {"code": ["def count_special_subsegments(n, p):\n    max_p = max(p)\n    left_index = {x: i for i, x in enumerate(p)}\n    right_index = {x: i for i, x in enumerate(reversed(p))}\n    special_subsegments = 0\n    for i in range(n):\n        if p[i] == max_p:\n            special_subsegments += min(i - left_index[max_p], right_index[max_p])\n    return special_subsegments\n\nn = int(input())\np = list(map(int, input().split()))\nprint(count_special_sub", "def count_special_subsegments(n, p):\n    count = 0\n    max_val = max(p)\n    l = 0\n    r = n - 1\n    while l < n and p[l] != max_val:\n        l += 1\n    while r > l and p[r] != max_val:\n        r -= 1\n    count = max(0, r - l + 1)\n    return count\n\nn = int(input())\np = list(map(int, input().split()))\nprint(count_special_subsegments(n, p))\n\n\nThis python code first finds the maximum value in the given permutation. Then it finds the first", "def solve(n, p):\n    max_p = max(p)\n    l = r = p.index(max_p)\n    ans = 0\n    while l > 0 or r < n-1:\n        if l == 0 or (r < n-1 and p[r+1] > p[l-1]):\n            r += 1\n            while r < n-1 and p[r+1] < p[r]:\n                r += 1\n        else:\n            l -= 1\n            while l > 0 and p[l-1] < p[l]:\n                l -= 1\n        if p[l] + p[r] == max_p:\n            ans", "def count_special_subsegments(n, p):\n    max_val = max(p)\n    max_index = p.index(max_val)\n    left_count = p[:max_index+1].count(max_val)\n    right_count = p[max_index:].count(max_val)\n    return left_count * right_count\n\nn = int(input())\np = list(map(int, input().split()))\nprint(count_special_subsegments(n, p))\n\n\nThis Python code first finds the maximum value in the permutation and its index. Then it counts the number of occurrences of this maximum value in the left and right parts of the", "n = int(input())\np = list(map(int, input().split()))\n\nmax_val = max(p)\n\nl = 0\nr = n - 1\n\nwhile p[l] != max_val:\n    l += 1\n\nwhile p[r] != max_val:\n    r -= 1\n\nprint(min(l, n - r - 1) + 1)\n\nThis code works by first finding the maximum value in the array and then finding the first and last occurrences of this value. The number of special subsegments is then the minimum of these two indices plus one."], "prompt": "\nQUESTION:\nYou are given a permutation $p$ of $n$ integers $1$, $2$, ..., $n$ (a permutation is an array where each element from $1$ to $n$ occurs exactly once).\n\nLet's call some subsegment $p[l, r]$ of this permutation special if $p_l + p_r = \\max \\limits_{i = l}^{r} p_i$. Please calculate the number of special subsegments.\n\n\n-----Input-----\n\nThe first line contains one integer $n$ ($3 \\le n \\le 2 \\cdot 10^5$).\n\nThe second line contains $n$ integers $p_1$, $p_2$, ..., $p_n$ ($1 \\le p_i \\le n$). All these integers are pairwise distinct.\n\n\n-----Output-----\n\nPrint the number of special subsegments of the given permutation.\n\n\n-----Examples-----\nInput\n5\n3 4 1 5 2\n\nOutput\n2\n\nInput\n3\n1 3 2\n\nOutput\n1\n\n\n\n-----Note-----\n\nSpecial subsegments in the first example are $[1, 5]$ and $[1, 3]$.\n\nThe only special subsegment in the second example is $[1, 3]$.\nPlease provide the solution as pure code only, without explanations or comments.\n\nANSWER:\n```python\n"}}