{"2885": {"code": ["class Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        result, merge = [], []\n        i, start, end = 0, 0, 1\n\n        # add all intervals that end before newInterval starts\n        while i < len(intervals) and intervals[i][end] < newInterval[start]:\n            result.append(intervals[i])\n            i += 1\n\n        # merge all intervals that start before newInterval ends\n        while i < len(intervals) and intervals[i][start] <= newInterval[end]:\n            newInterval = [min(intervals[i][start], newInterval[start]), max(intervals[i][end], newInterval[end])]\n            i += 1\n\n        result.append(newInterval)\n\n        # add the rest\n        while i < len(intervals):\n            result.append(intervals[i])\n            i += 1\n        return result\n\n\nThis solution works by first", "class Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        result = []\n        i = 0\n        while i < len(intervals) and intervals[i][1] < newInterval[0]:\n            result.append(intervals[i])\n            i += 1\n        \n        while i < len(intervals) and intervals[i][0] <= newInterval[1]:\n            newInterval = [min(intervals[i][0], newInterval[0]), max(intervals[i][1], newInterval[1])]\n            i += 1\n        result.append(newInterval)\n        \n        while i < len(intervals):\n            result.append(intervals[i])\n            i += 1\n        return result\n\n\nThis solution works by first appending all intervals that end before the start of the new interval to the result. Then, it merges all overlapping intervals with the new interval. Finally, it appends the remaining intervals to the result.", "class Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        result = []\n        i = 0\n        while i < len(intervals) and intervals[i][1] < newInterval[0]:\n            result.append(intervals[i])\n            i += 1\n\n        while i < len(intervals) and intervals[i][0] <= newInterval[1]:\n            newInterval = [min(intervals[i][0], newInterval[0]), max(intervals[i][1], newInterval[1])]\n            i += 1\n        result.append(newInterval)\n\n        while i < len(intervals):\n            result.append(intervals[i])\n            i += 1\n        return result\n\n\n\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        res, i = [], 0", "class Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        result = []\n        i = 0\n        while i < len(intervals) and intervals[i][1] < newInterval[0]:\n            result.append(intervals[i])\n            i += 1\n\n        while i < len(intervals) and intervals[i][0] <= newInterval[1]:\n            newInterval = [min(intervals[i][0], newInterval[0]), max(intervals[i][1], newInterval[1])]\n            i += 1\n        result.append(newInterval)\n\n        while i < len(intervals):\n            result.append(intervals[i])\n            i += 1\n        return result\n\n\nThis code works by first appending to the result any intervals that end before the start of the new one. Then, it merges overlapping intervals by continually updating the newInterval until there are no more overlaps. Finally, it appends the", "class Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        result = []\n        i = 0\n        while i < len(intervals) and intervals[i][1] < newInterval[0]:\n            result.append(intervals[i])\n            i += 1\n\n        while i < len(intervals) and intervals[i][0] <= newInterval[1]:\n            newInterval = [min(intervals[i][0], newInterval[0]), max(intervals[i][1], newInterval[1])]\n            i += 1\n\n        result.append(newInterval)\n        \n        while i < len(intervals):\n            result.append(intervals[i])\n            i += 1\n            \n        return result\n\n\nThis solution works by iterating through the intervals. If the current interval does not overlap with the new interval, it is added to the result. If it does overlap, the new interval is updated to be the merged interval and the"], "prompt": "\nQUESTION:\nGiven a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).\n\nYou may assume that the intervals were initially sorted according to their start times.\n\nExample 1:\n\n\nInput: intervals = [[1,3],[6,9]], newInterval = [2,5]\nOutput: [[1,5],[6,9]]\n\n\nExample 2:\n\n\nInput: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]\nOutput: [[1,2],[3,10],[12,16]]\nExplanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].\nSTARTER CODE:\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        \n\nPlease provide the solution as pure code only, without explanations or comments.\n\nANSWER:\n```python\n"}}