{"1427": {"code": ["from sys import stdin\n\nMOD = 10**9+7\nN = int(stdin.readline().strip())\nA = list(map(int, stdin.readline().strip().split()))\n\nA.sort()\nB = [pow(A[i], MOD-2, MOD) for i in range(N)]\n\nres = 0\nfor i in range(N):\n    res = (res + A[i] * B[i] % MOD * B[i] % MOD) % MOD\n\nprint(res)\n\n\nExplanation:\nThis solution works by first sorting the list of A_i's. Then, for each A_i, it calculates B_i as A_i^(MOD-2) mod MOD. This is because A_i * B_i = A_j * B_", "import sys\nfrom fractions import gcd\ninput = sys.stdin.readline\nMOD = 10**9+7\nN = int(input())\nA = list(map(int, input().split()))\nlcm = A[0]\nfor i in range(1, N):\n    lcm = lcm*A[i]//gcd(lcm, A[i])\nprint(lcm%MOD)\n\n\nThis program uses the gcd function from the fractions module to find the greatest common divisor of two numbers. It then calculates the least common multiple (lcm) of the list of numbers using the formula lcm(a, b) = a*b // gcd(a, b). The result is then printed modulo (10^9 + 7) to prevent overflow.\n\nThe reason this works is that the condition for B_i to satisfy", "MOD = 10**9 + 7\nN = int(input())\nA = list(map(int, input().split()))\n\n# Calculate the gcd of all A_i and lcm of all A_i\nfrom math import gcd\nfrom functools import reduce\ndef lcm(a, b):\n    return a * b // gcd(a, b)\nA_lcm = reduce(lcm, A, 1)\n\n# The minimum possible value of B_i is A_i * lcm_of_A / A_i\nB = [A_lcm * a // a for a in A]\n\nprint(sum(B) % MOD)\n\n\nThis solution first calculates the least common multiple (lcm) of all the A_i using the reduce function and the lcm function. Then it calculates B_i as the", "from sys import stdin\nfrom heapq import heappush, heappop\n\nMOD = 10**9 + 7\n\ndef solve():\n    _, *a = map(int, stdin.read().split())\n    h = []\n    for x in a:\n        heappush(h, -x)\n    b = [0]*len(a)\n    for i in range(len(a)):\n        x = -heappop(h)\n        b[i] = x if i == 0 or b[i-1]*a[i-1] > b[i-2]*a[i-2] else b[i-2]\n        heappush(h, -b[i])\n    print(sum(b) % MOD)\n\nsolve()\n\n\nThis solution uses a heap to keep track of the", "MOD = 10**9+7\nN = int(input())\nA = list(map(int, input().split()))\nA.sort()\nB = [1]*N\nfor i in range(N):\n    B[i] = (A[i]*B[i-1])%MOD\nprint(sum(B)%MOD)\n\n\nEXPLANATION:\nThe problem is asking for the minimum possible sum of B_i where the condition A_i*B_i = A_j*B_j holds for all i, j. \n\nThe condition can be rewritten as A_i/A_j = B_i/B_j. This means that for any i, j such that 1 <= i < j <= N, A_i/A_j = B_i/B_j.\n\nSince A_i and A_"], "prompt": "\nQUESTION:\nGiven are N positive integers A_1,...,A_N.\nConsider positive integers B_1, ..., B_N that satisfy the following condition.\nCondition: For any i, j such that 1 \\leq i < j \\leq N, A_i B_i = A_j B_j holds.\nFind the minimum possible value of B_1 + ... + B_N for such B_1,...,B_N.\nSince the answer can be enormous, print the sum modulo (10^9 +7).\n\n-----Constraints-----\n - 1 \\leq N \\leq 10^4\n - 1 \\leq A_i \\leq 10^6\n - All values in input are integers.\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN\nA_1 ... A_N\n\n-----Output-----\nPrint the minimum possible value of B_1 + ... + B_N for B_1,...,B_N that satisfy the condition, modulo (10^9 +7).\n\n-----Sample Input-----\n3\n2 3 4\n\n-----Sample Output-----\n13\n\nLet B_1=6, B_2=4, and B_3=3, and the condition will be satisfied.\nPlease provide the solution as pure code only, without explanations or comments.\n\nANSWER:\n```python\n"}}