{"711": {"code": ["def powmod(a, b, mod):\n    r = 1\n    while b > 0:\n        if b % 2 == 1:\n            r = r * a % mod\n        a = a * a % mod\n        b = b // 2\n    return r\n\ndef solve(n, m):\n    primes = []\n    for i in range(2, int(m ** 0.5) + 1):\n        if m % i == 0:\n            primes.append(i)\n            while m % i == 0:\n                m //= i\n    if m > 1:\n        primes.append(m)\n\n    mod = 10**9 + 7\n    ans = 1\n    for prime in primes:\n        cnt = 0\n        while m % prime == 0:\n            m //= prime\n            cnt += 1\n        ans = ans * (powmod(prime, cnt * n + 1) - 1) % mod * powmod(prime - 1, mod - 2) %", "MOD = 10**9+7\nN, M = map(int, input().split())\n\ndef factorize(n):\n    i = 2\n    factors = []\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return factors\n\nfactors = factorize(M)\nn = len(factors)\n\ndp = [0] * (N+1)\ndp[0] = 1\n\nfor factor in factors:\n    for i in range(N, 0, -1):\n        for j in range(1, min(i+1, factor+1)):\n            dp[i] = (dp[i] + dp[i-j]) % MOD\n\nprint(dp[N])\n\n\nThis code first factorizes the given integer M into its prime factors. Then it uses dynamic programming to count the number of sequences that can be", "from collections import Counter\nfrom math import gcd\n\nMOD = 10**9 + 7\nN, M = map(int, input().split())\n\ndef prime_factors(n):\n    i = 2\n    factors = []\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return factors\n\ndef multinomial(n, r):\n    num = 1\n    den = 1\n    for i in range(r):\n        num = (num * (n - i)) % MOD\n        den = (den * (i + 1)) % MOD\n    return (num * pow(den, MOD - 2, MOD)) % MOD\n\nfactors = prime_factors(M)\ncounts = Counter(factors)\n\nres = 1\nfor v in counts.values():\n    res = (res * multinomial", "N, M = map(int, input().split())\nmod = 10**9+7\n\nfactor = [0]*(M+1)\nfactor[1] = 1\nfor i in range(2, M+1):\n    factor[i] = factor[i-1]*i%mod\n\ninv = [0]*(M+1)\ninv[M] = pow(factor[M], mod-2, mod)\nfor i in range(M-1, 0, -1):\n    inv[i] = inv[i+1]*(i+1)%mod\n\ndef C(n, r):\n    if r > n or r < 0:\n        return 0\n    return factor[n]*inv[n-r]%mod*inv[r]%mod\n\ncount = [0]*(M+1)\nfor i in range(1, M+1):\n    count[i] = count[i-1]\n    j = 1\n    while i*j <= M:\n        count[i] =", "MOD = 10**9 + 7\nN, M = map(int, input().split())\nfact = [1]*(N+1)\ninvfact = [1]*(N+1)\nfor i in range(1, N+1):\n    fact[i] = (fact[i-1]*i)%MOD\n    invfact[i] = pow(fact[i], MOD-2, MOD)\ndef comb(n, r):\n    if r < 0 or r > n:\n        return 0\n    return (fact[n]*invfact[r]*invfact[n-r])%MOD\nprimes = []\ni = 2\nwhile i*i <= M:\n    if M%i:\n        i += 1\n    else:\n        cnt = 0\n        while M%i == 0:\n            M //= i\n            cnt += 1\n        primes.append(cnt)\nif M > 1:\n    primes.append(1)\nres = 1\nfor cnt in primes"], "prompt": "\nQUESTION:\nYou are given positive integers N and M.\nHow many sequences a of length N consisting of positive integers satisfy a_1 \\times a_2 \\times ... \\times a_N = M? Find the count modulo 10^9+7.\nHere, two sequences a' and a'' are considered different when there exists some i such that a_i' \\neq a_i''.\n\n-----Constraints-----\n - All values in input are integers.\n - 1 \\leq N \\leq 10^5\n - 1 \\leq M \\leq 10^9\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN M\n\n-----Output-----\nPrint the number of the sequences consisting of positive integers that satisfy the condition, modulo 10^9 + 7.\n\n-----Sample Input-----\n2 6\n\n-----Sample Output-----\n4\n\nFour sequences satisfy the condition: \\{a_1, a_2\\} = \\{1, 6\\}, \\{2, 3\\}, \\{3, 2\\} and \\{6, 1\\}.\nPlease provide the solution as pure code only, without explanations or comments.\n\nANSWER:\n```python\n"}}