{"2632": {"code": ["class Solution:\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        dp = [[0]*n for _ in range(m)]\n        dp[0][0] = grid[0][0]\n        for i in range(1, m):\n            dp[i][0] = dp[i-1][0] + grid[i][0]\n        for j in range(1, n):\n            dp[0][j] = dp[0][j-1] + grid[0][j]\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n        return dp[-1][-1]\n\n\nEXPLANATION:\nThis solution uses dynamic programming. First, create a 2D list dp with the same size as the input grid, and initialize the top-left cell with the value of the top-left cell of the input grid. Then fill in the first row and the first column by adding the current cell's value and the value of the cell in the previous column/row. Finally, for each cell in the rest of the grid, calculate the minimum path sum from the", "class Solution:\n    def minPathSum(self, grid):\n        m = len(grid)\n        n = len(grid[0])\n\n        # Initialize the first cell\n        dp = grid[0]\n\n        # For each remaining row, update the values in dp\n        for i in range(1, n):\n            dp[i] += dp[i - 1]\n\n        # For each remaining cell in the grid\n        for i in range(1, m):\n            dp[0] += grid[i][0]\n            for j in range(1, n):\n                # The value at each cell is the current cell plus the minimum of the two possible previous cells\n                dp[j] = grid[i][j] + min(dp[j - 1], dp[j])\n\n        # The minimum path sum is the last cell in dp\n        return dp[-1]\n\n\nExplanation:\nWe use a dynamic programming approach. We initialize a list dp with the same length as the first row in the grid, and we fill it with the values from the first row. For each remaining row, we add the current row's values to the values in dp, and we update dp. We then do the same for the remaining cells in the grid, but we only add the current cell's value and the minimum of the two possible previous cell's values. The minimum path", "class Solution:\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        if not grid:\n            return 0\n\n        m, n = len(grid), len(grid[0])\n        dp = [[0]*n for _ in range(m)]\n        dp[0][0] = grid[0][0]\n\n        for i in range(1, m):\n            dp[i][0] = dp[i-1][0]+grid[i][0]\n        for j in range(1, n):\n            dp[0][j] = dp[0][j-1]+grid[0][j]\n\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n        return dp[-1][-1]\n\n'''\n\nclass Solution:\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        if not grid:\n            return 0\n\n        m, n = len(grid), len(grid[0])\n        dp = [[0]*n for _ in range(m)]\n        dp[0][0] = grid[0", "class Solution:\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        m = len(grid)\n        n = len(grid[0])\n        \n        for i in range(1, n):\n            grid[0][i] += grid[0][i - 1]\n        for i in range(1, m):\n            grid[i][0] += grid[i - 1][0]\n        \n        for i in range(1, m):\n            for j in range(1, n):\n                grid[i][j] += min(grid[i - 1][j], grid[i][j - 1])\n        \n        return grid[-1][-1]\n\n\nEXPLANATION:\nThis solution uses dynamic programming. For each cell in the grid, we compute the minimum path sum by either coming from the left (adding the current cell's value to the left's minimum path sum) or from above (adding the current cell's value to the top's minimum path sum). We do this by iterating over the grid once, updating the cell values in-place. Finally, the bottom-right cell's value is the minimum path sum.\n\nThis solution has a time complexity of O(m*n) because we're updating each cell once, and a space complexity of O(1) because we're updating the input grid in-place.\n'''", "class Solution:\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        if not grid:\n            return 0\n\n        m, n = len(grid), len(grid[0])\n        dp = [[0]*n for _ in range(m)]\n        dp[0][0] = grid[0][0]\n\n        for i in range(1, m):\n            dp[i][0] = dp[i-1][0] + grid[i][0]\n\n        for j in range(1, n):\n            dp[0][j] = dp[0][j-1] + grid[0][j]\n\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n        return dp[-1][-1]\n\n\nThis solution works by initializing a 2D DP array of the same size as the input grid, where dp[i][j] is the minimum path sum from the top left cell to cell (i, j). It then fills in the DP array by iterating through the grid, calculating the minimum path sum for each cell by considering the minimum path sum of the cell's top and left neighbors."], "prompt": "\nQUESTION:\nGiven a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.\n\nNote: You can only move either down or right at any point in time.\n\nExample:\n\n\nInput:\n[\n\u00a0 [1,3,1],\n  [1,5,1],\n  [4,2,1]\n]\nOutput: 7\nExplanation: Because the path 1\u21923\u21921\u21921\u21921 minimizes the sum.\nSTARTER CODE:\nclass Solution:\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        \n\nPlease provide the solution as pure code only, without explanations or comments.\n\nANSWER:\n```python\n"}}