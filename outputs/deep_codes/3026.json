{"3026": {"code": ["from bisect import bisect_left\n\ndef longest_increasing_subsequence(seq):\n    seq = [0] + seq\n    n = len(seq)\n    m = [0] * n\n    p = [0] * n\n    t = []\n\n    l = 0\n    for i in range(1, n):\n        if not t or seq[i] > seq[t[-1]]:\n            t.append(i)\n            m[i] = l\n            p[i] = t[m[i-1]] if m[i-1] > 0 else 0\n            l += 1\n        else:\n            pos = bisect_left", "from bisect import bisect_left, bisect_right\n\ndef binary_search(arr, x):\n    i = bisect_left(arr, x)\n    if i != len(arr) and arr[i] == x:\n        return True\n    return False\n\ndef solve():\n    n = int(input())\n    arr = list(map(int, input().split()))\n    lis = [0] * n\n    lis[0] = arr[0]\n    length = 1\n    for i in range(1, n):\n        if arr[i] < lis[0]:\n            lis[0] = arr[i]\n        elif arr[i]", "from bisect import bisect_left, bisect_right\n\ndef binary_search(arr, x):\n    i = bisect_left(arr, x)\n    if i != len(arr) and arr[i] == x:\n        return True\n    else:\n        return False\n\nn = int(input())\narr = list(map(int, input().split()))\nlis = [0]\nseq = [0]*(n+1)\n\nfor i in range(n):\n    if arr[i] > lis[-1]:\n        lis.append(arr[i])\n    else:\n        idx = bisect_left(lis, arr[i])\n        l", "def find_critical_elements(n, sequence):\n    # Initialize two lists to store the original and reversed sequence\n    original_sequence = [0] * n\n    reversed_sequence = [0] * n\n\n    # Copy the sequence into the original and reversed lists\n    for i in range(n):\n        original_sequence[i] = sequence[i]\n        reversed_sequence[n - i - 1] = sequence[i]\n\n    # Initialize the LIS lengths for the original and reversed sequences\n    lis_lengths_original = [1] * n\n    lis_lengths_reversed = [1] * n\n\n    # Compute", "from bisect import bisect_left, bisect_right\n\ndef binary_search(a, x, lo=0, hi=None):\n    if hi is None:\n        hi = len(a)\n    pos = bisect_right(a, x, lo, hi)\n    if pos == lo:\n        return None\n    return pos\n\nn = int(input())\na = list(map(int, input().split()))\n\nlis = [a[0]]\npos = [0] * n\np = [0] * n\n\nfor i in range(1, n):\n    if a[i] > lis[-1]:\n        lis.append(a[i])"], "prompt": "\nQUESTION:\nZapray really loves the Algorithmic Problem Solving course, but he is struggling with it. Recently the class studied Longest Increasing Subsequence (LIS). Zapray knows well how to compute the length of LIS for a given sequence. But on the exam paper there appears to be a different question: \u201cWe say an element in a sequence is critical, if removing it will cause the sequence\u2019s LIS length to decrease. Can you find all the critical elements in the sequence below?\u201d Zapray soon realizes that this is a much bigger challenge.\n\n-----Input-----\nThe input starts with a single integer $n$ ($2 \\leq n \\leq 10^5$), the length of the given sequence. The next line has $n$ integers giving the numbers in the sequence. The given sequence is a permutation in which each integer from $1$ to $n$ appears exactly once.\n\n-----Output-----\nOutput all critical elements in the sequence in ascending order. If none of the elements are critical, output \u201c-1\u201d.\n\n-----Examples-----\nSample Input 1:\n4\n1 3 2 4\nSample Output 1:\n1 4\n\nSample Input 2:\n5\n1 2 3 4 5\nSample Output 2:\n1 2 3 4 5\n\nSample Input 3:\n4\n2 1 4 3\nSample Output 3:\n-1\nPlease provide the solution as pure code only, without explanations or comments.\n\nANSWER:\n```python\n"}}