{"3593": {"code": ["def solve(N, K, board):\n    # Calculate the sum of numbers on each column.\n    sums = [0] * 3\n    for i in range(N):\n        for j in range(3):\n            sums[j] += abs(board[i][j])\n\n    # Sort the sums in decreasing order.\n    sums.sort(reverse=True)\n\n    # Use the largest sums for the dominoes.\n    return sum(sums[:K])\n\nN, K = map(int, input().split())\nboard = [list(map(int, input().split())) for _ in range(N)]\nprint(solve(N, K, board))\n\n\nThis solution works by first calculating the sum of the numbers on each column. It then sorts these sums in decreasing", "def solve(n, k, board):\n    # Sort each row in descending order\n    for i in range(n):\n        board[i] = sorted(board[i], reverse=True)\n\n    # Sort all rows in descending order of the sum of elements in each row\n    board = sorted(board, key=sum, reverse=True)\n\n    # Initialize result\n    res = 0\n\n    # Greedily select the maximum sum for each row\n    for i in range(n):\n        res += board[i][0]\n        k -= 1\n        if k == 0:\n            break\n        res += board[i][1]\n        k -= 1\n\n    return res\n\nn, k = map(int, input().split())\nboard = [list(map(", "N, K = map(int, input().split())\nA = [list(map(int, input().split())) for _ in range(N)]\nA.sort()\ndp = [[-1 << 60] * 4 for _ in range(N + 1)]\ndp[0][0] = 0\nfor i in range(N):\n    for j in range(4):\n        if dp[i][j] == -1 << 60: continue\n        dp[i + 1][j] = max(dp[i + 1][j], dp[i][j])\n        if j < 3: dp[i + 1][j + 1] = max(dp[i + 1][j + 1], dp[i][j] + A[i][1])\n        if i + 1", "N, K = map(int, input().split())\nA = [list(map(int, input().split())) for _ in range(N)]\ndp = [[-10**18] * 3 for _ in range(N+1)]\ndp[0][0] = 0\n\nfor i in range(N):\n    for j in range(3):\n        for k in range(3):\n            if j != k:\n                dp[i+1][k] = max(dp[i+1][k], dp[i][j] + A[i][k])\n\nprint(max(dp[N]))\n\n\nEXPLANATION:\nThis problem can be solved by using dynamic programming. The state dp[i][j] represents the maximum sum of numbers that can be", "N, K = map(int, input().split())\nboard = [list(map(int, input().split())) for _ in range(N)]\ndominoes = []\n\nfor row in board:\n    dominoes.append([sum(row), [row[0], row[2]]])\n\ndominoes.sort(reverse=True)\n\ntotal = 0\nfor i in range(K):\n    total += dominoes[i][0]\n\nprint(total)\n\nThis code first reads the input and converts the board into a list of dominoes, each represented as a tuple of the sum of the numbers in the domino and the numbers themselves. Then it sorts the list of dominoes in decreasing order. Finally, it sums the numbers in the first $K$ dominoes and prints"], "prompt": "\nQUESTION:\nMirko has a chessboard with $N$ rows and just three columns. Slavica has written an integer on each field. Mirko has $K$ dominoes at his disposal, their dimensions being $2 \\times 1$, and has to arrange all of them on the board without overlapping, in a way that each domino covers exactly two fields of the board. He can rotate the dominoes as he please\n\nHelp Mirko cover the largest sum of numbers possible with the dominoes!\n\n-----Input-----\nThe first line of input contains the integer $N$ ($1 \\le N \\le 1000$), the number of rows, and $K$ ($1 \\le K \\le 1000$), the number of dominoes available.\n\nEach of the following $N$ lines contains three integers written in the $i$\u2019th row of the board. All numbers will be less than $10^6$ in absolute value.\n\n-----Output-----\nThe first and only line of output must contain the maximal sum possible to cover with exactly $K$ dominoes.\n\n-----Examples-----\nSample Input:\n5 3\n2 1 -1\n1 3 2\n0 2 3\n2 1 1\n3 3 0\nSample Output:\n16\nPlease provide the solution as pure code only, without explanations or comments.\n\nANSWER:\n```python\n"}}