{"4390": {"code": ["t = int(input())\nfor _ in range(t):\n    a, b = map(int, input().split())\n    print((b - a % b) % b)\n\nThis code works by taking the modulus of `b` with `a` to find the remainder. If `a` is already divisible by `b`, the remainder will be `0`. Otherwise, the minimum number of moves required to make `a` divisible by `b` is `b - a % b`. The modulus operator is used to ensure the result is always non-negative.", "t = int(input())\nfor _ in range(t):\n    a, b = map(int, input().split())\n    print((a + b - 1) // b * b - a)\n\nThis solution uses integer division to round up to the nearest multiple of `b`, then subtracts `a` to get the minimum number of moves. It works because `(a + b - 1) // b * b` is the smallest multiple of `b` that is not less than `a`, and `(a + b - 1) // b * b - a` is the number of moves needed to make `a` divisible by `b`.\n\nExplanation:\nThe expression `(a + b - 1) // b * b` rounds up `a` to the nearest multiple of `b`. This is done by adding `", "t = int(input())\nfor _ in range(t):\n    a, b = map(int, input().split())\n    print((a + b - 1) // b * b - a)\n\n\nEXPLANATION:\nIn the provided solution, we take the inputs for each test case and calculate the minimum number of moves required to make `a` divisible by `b`. We do this by using the mathematical concept of division. \n\nThe formula `(a + b - 1) // b * b` is used to round up `a` to the nearest multiple of `b`. This is equivalent to `ceil(a / b) * b`. \n\nSubtracting `a` from this result gives the minimum number of moves required to make `a` divisible by `b`. \n\nThis solution works for all test cases as", "t = int(input())\nfor _ in range(t):\n    a, b = map(int, input().split())\n    print((b - a % b) % b)\n\n\nExplanation:\n\nThe minimum number of moves to make `a` divisible by `b` is given by `b - a mod b`. The `%` operator gives the remainder of the division of `a` by `b`. If `a` is already divisible by `b`, then `a mod b` is `0` and the result is `0` as well.\n\nThe `(x + y) % z = (x % z + y % z) % z` property is used to avoid overflow.\n\nThis code reads the number of test cases `t` and for each test case it reads two integers `a` and `b`. It", "t = int(input())\nfor _ in range(t):\n    a, b = map(int, input().split())\n    print((b - a % b) % b)\n\nThis Python code reads the number of test cases and for each test case, it reads the two numbers a and b. It then calculates the remainder of a divided by b and subtracts this from b. The result is the minimum number of moves needed to make a divisible by b. The modulo operator is used to ensure that the result is always non-negative.\n\nThe code uses a for loop to process each test case. The input function is used to read the number of test cases and the numbers a and b. The map function is used to convert the input strings to integers. The print function is used to output the result.\n\nThis code assumes that the inputs are valid and does not include any error"], "prompt": "\nQUESTION:\nYou are given two positive integers $a$ and $b$. In one move you can increase $a$ by $1$ (replace $a$ with $a+1$). Your task is to find the minimum number of moves you need to do in order to make $a$ divisible by $b$. It is possible, that you have to make $0$ moves, as $a$ is already divisible by $b$. You have to answer $t$ independent test cases.\n\n\n-----Input-----\n\nThe first line of the input contains one integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases. Then $t$ test cases follow.\n\nThe only line of the test case contains two integers $a$ and $b$ ($1 \\le a, b \\le 10^9$).\n\n\n-----Output-----\n\nFor each test case print the answer \u2014 the minimum number of moves you need to do in order to make $a$ divisible by $b$.\n\n\n-----Example-----\nInput\n5\n10 4\n13 9\n100 13\n123 456\n92 46\n\nOutput\n2\n5\n4\n333\n0\nPlease provide the solution as pure code only, without explanations or comments.\n\nANSWER:\n```python\n"}}