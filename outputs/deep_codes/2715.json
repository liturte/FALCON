{"2715": {"code": ["K = int(input())\n\nif K == 0:\n    print(4)\n    print(\"3 3 3 3\")\nelse:\n    N = 50\n    a = [1]*N\n    K -= 1\n    while K > 0:\n        a[K % N] += 1\n        K //= N\n    print(N)\n    print(\" \".join(map(str, a)))\n\n\nExplanation:\nThe problem can be solved by a simple greedy algorithm. We start with a sequence of length N = 50 filled with ones. Then we perform the operation K times. Each time, we find the largest element in the sequence, decrease its value by N and increase the other elements by 1. This can be done by finding", "def solve(K):\n    N = 1\n    while K >= N:\n        K -= N\n        N += 1\n    a = [N] * N\n    for _ in range(K):\n        idx = a.index(max(a))\n        a[idx] -= N\n        for i in range(N):\n            if i != idx:\n                a[i] += 1\n    return N, a\n\nK = int(input())\nN, a = solve(K)\nprint(N)\nprint(' '.join(map(str, a)))\n\n\nThis Python code solves the problem by first determining the optimal number of operations N using a while loop that continually subtracts N from K until K is less than N. Then,", "import sys\n\nK = int(sys.stdin.readline().strip())\n\nif K == 0:\n    print(4)\n    print(\"3 3 3 3\")\nelse:\n    N = 50\n    a = [1] * N\n    K -= 1\n\n    while K > 0:\n        if K % 2 == 1:\n            a[0] += 1\n        K //= 2\n        for i in range(N - 1):\n            if a[i] > a[i + 1]:\n                a[i + 1] += 1\n                a[i] -= 1\n\n    print(N)\n    print(\" \".join(map(str, a)))\n\n\nThis code first checks if", "import sys\n\ndef solve(K):\n    if K == 0:\n        print(1)\n        print(0)\n        sys.exit()\n    N = 0\n    while (N+1)*(N+1) <= 2*K:\n        N += 1\n    a = [N]*N\n    K -= N*N\n    for _ in range(K):\n        a[a.index(max(a))] -= 1\n        a[a.index(max(a))] += 1\n    print(N)\n    print(' '.join(map(str, a)))\n\nsolve(int(input()))\n\n\nEXPLANATION:\nThis Python script solves the problem by first finding the largest possible N such that", "import sys\n\nK = int(sys.stdin.readline().strip())\nN = 1\nwhile K >= 2 * (N * (N - 1) // 2):\n    N += 1\nN -= 1\nK -= (N * (N - 1) // 2)\n\na = [N] * N\nfor _ in range(K):\n    a[a.index(max(a))] -= 1\n    a[0] += 1\n\nprint(N+1)\nprint(*a)\n\n\nThis program first calculates the largest `N` such that `2 * (N * (N - 1) // 2)` is less than or equal to `K`. This `N` is the initial number"], "prompt": "\nQUESTION:\nWe have a sequence of length N consisting of non-negative integers. Consider performing the following operation on this sequence until the largest element in this sequence becomes N-1 or smaller.\n - Determine the largest element in the sequence (if there is more than one, choose one). Decrease the value of this element by N, and increase each of the other elements by 1.\nIt can be proved that the largest element in the sequence becomes N-1 or smaller after a finite number of operations.\nYou are given an integer K. Find an integer sequence a_i such that the number of times we will perform the above operation is exactly K. It can be shown that there is always such a sequence under the constraints on input and output in this problem.\n\n-----Constraints-----\n - 0 \u2264 K \u2264 50 \\times 10^{16}\n\n-----Input-----\nInput is given from Standard Input in the following format:\nK\n\n-----Output-----\nPrint a solution in the following format:\nN\na_1 a_2 ... a_N\n\nHere, 2 \u2264 N \u2264 50 and 0 \u2264 a_i \u2264 10^{16} + 1000 must hold.\n\n-----Sample Input-----\n0\n\n-----Sample Output-----\n4\n3 3 3 3\n\nPlease provide the solution as pure code only, without explanations or comments.\n\nANSWER:\n```python\n"}}