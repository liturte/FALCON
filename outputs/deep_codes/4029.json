{"4029": {"code": ["from collections import deque\n\ndef bfs(n):\n    queue = deque([(n, 0)])\n    visited = set()\n    while queue:\n        num, steps = queue.popleft()\n        if num % 25 == 0:\n            return steps\n        for i in range(len(num)):\n            for j in range(i+2, len(num)+1):\n                next_num = int(num[:i] + num[i+1:j] + num[i] + num[j:])\n                if next_num not", "n = input()\n\nif int(n) % 5 == 0:\n    print(0)\nelif len(set(n)) == 1 and n[0] in '13579':\n    print(-1)\nelse:\n    cnt, i, j = [0]*10, 0, 1\n    while j < len(n) or i < len(n):\n        if n[j] in '2468':\n            cnt[int(n[i])] += 1\n            i += 1\n            if i == len(n", "n = input()\n\ndef min_moves(n):\n    if len(n) == 1:\n        return 0 if int(n) % 5 == 0 else -1\n    moves = 0\n    for i in range(len(n) - 1):\n        if int(n[i:i+2]) % 25 == 0:\n            return moves + min_moves(n[:i] + n[i+2:] if i > 0 else n[i+2:])\n        if n[i] == '0':\n            continue\n        n1 =", "def min_moves(n):\n    n = str(n)\n    moves = 0\n    for i in range(len(n) - 1):\n        if int(n[i:i+2]) % 25 != 0:\n            moves += 1\n            if n[i] == '0':\n                n = n[:i] + n[i+1] + n[i] + n[i+2:]\n            elif n[i+1] == '0':\n                n = n[:i] + n[i+2] + n[i] +", "from collections import deque\n\ndef min_moves(n):\n    if int(n) % 5 == 0:\n        return 0\n\n    n = str(n)\n    q = deque([(d, 0) for d in n])\n    seen = set()\n\n    while q:\n        cur, moves = q.popleft()\n        for i in range(len(cur)):\n            for j in range(i+1, len(cur)):\n                if cur[i] != '0' and cur[j] != '0':"], "prompt": "\nQUESTION:\nYou are given an integer $n$ from $1$ to $10^{18}$ without leading zeroes.\n\nIn one move you can swap any two adjacent digits in the given number in such a way that the resulting number will not contain leading zeroes. In other words, after each move the number you have cannot contain any leading zeroes.\n\nWhat is the minimum number of moves you have to make to obtain a number that is divisible by $25$? Print -1 if it is impossible to obtain a number that is divisible by $25$.\n\n\n-----Input-----\n\nThe first line contains an integer $n$ ($1 \\le n \\le 10^{18}$). It is guaranteed that the first (left) digit of the number $n$ is not a zero.\n\n\n-----Output-----\n\nIf it is impossible to obtain a number that is divisible by $25$, print -1. Otherwise print the minimum number of moves required to obtain such number.\n\nNote that you can swap only adjacent digits in the given number.\n\n\n-----Examples-----\nInput\n5071\n\nOutput\n4\n\nInput\n705\n\nOutput\n1\n\nInput\n1241367\n\nOutput\n-1\n\n\n\n-----Note-----\n\nIn the first example one of the possible sequences of moves is 5071 $\\rightarrow$ 5701 $\\rightarrow$ 7501 $\\rightarrow$ 7510 $\\rightarrow$ 7150.\nPlease provide the solution as pure code only, without explanations or comments.\n\nANSWER:\n```python\n"}}