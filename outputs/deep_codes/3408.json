{"3408": {"code": ["from collections import defaultdict\n\nN, Q = map(int, input().split())\nwords = [input() for _ in range(N)]\nqueries = [input() for _ in range(Q)]\n\n# Create a dictionary to store the counts of each character\ncounts = defaultdict(int)\nfor word in words:\n    for char in word:\n        counts[char] += 1\n\n# Process each query\nfor query in queries:\n    # Create a copy of the counts dictionary to avoid modifying it while iterating\n    temp_counts = counts.copy()\n    # Check if the query can be", "from collections import defaultdict\n\nN, Q = map(int, input().split())\nwords = [input() for _ in range(N)]\nqueries = [input() for _ in range(Q)]\n\n# Create a dictionary to store the count of words for each character\ncounts = defaultdict(int)\nfor word in words:\n    for char in word:\n        counts[char] += 1\n\n# Process each query\nfor query in queries:\n    # Count the number of '*' in the query\n    star_count = query.count('*')\n    \n    # If the query contains only one", "from collections import defaultdict\n\ndef solve(words, patterns):\n    word_dict = defaultdict(list)\n    for word in words:\n        word_dict[len(word)].append(word)\n\n    pattern_dict = defaultdict(list)\n    for pattern in patterns:\n        pattern_dict[len(pattern)].append(pattern)\n\n    count_dict = defaultdict(int)\n    for pattern_length, patterns in pattern_dict.items():\n        for pattern in patterns:\n            for word_length, words in word_dict.items():\n                if pattern_length >= word_", "from collections import defaultdict\n\nN, Q = map(int, input().split())\nwords = [input() for _ in range(N)]\nqueries = [input() for _ in range(Q)]\n\n# Create a dictionary to store the count of words for each pattern\npattern_counts = defaultdict(int)\nfor word in words:\n    for i in range(len(word)):\n        pattern = word[:i] + \"*\" + word[i+1:]\n        pattern_counts[pattern] += 1\n\n# Print the count for each query\nfor query in queries:\n    print(pattern", "from collections import defaultdict\n\ndef solve():\n    N, Q = map(int, input().split())\n    words = [input() for _ in range(N)]\n    patterns = [input() for _ in range(Q)]\n    \n    prefixes = defaultdict(set)\n    suffixes = defaultdict(set)\n    \n    for word in words:\n        prefixes[word[0]].add(word)\n        suffixes[word[-1]].add(word)\n    \n    for pattern in patterns:\n        if pattern[0] == \"*\":\n            print(len(suffix"], "prompt": "\nQUESTION:\nLittle Matej is solving an OOP (Object-oriented programming) laboratory exercise and he\u2019s having trouble with solving one subtask.\n\nHe is given a set that contains $N$ words. He is also given $Q$ queries where each query is one pattern. A pattern consists of a single character \u201c*\u201d and lowercase letters of the English alphabet. For example, \u201c*\u201d, \u201ckul*to\u201d, \u201cana*\u201d.\n\nA pattern is said to cover a word if such an array of letters (which can be empty) exists that, when replacing the character \u201c*\u201d, the pattern and the word become completely identical. It is necessary to output how many words each pattern covers.\n\n-----Input-----\nThe first line of input contains two integers $N$ and $Q$ ($1 \\leq N, Q \\leq 100000$). Each of the following $N$ lines contains a word that consists of lowercase letters of the English alphabet. Each of the following $Q$ lines contains a pattern for which you need to output how many words from the first set it covers. The total number of characters will be less than $4000000$.\n\n-----Output-----\nOutput $Q$ lines, the $k$-th line containing the number of words that the $k$-th pattern covers.\n\n-----Examples-----\nSample Input:\n3 3\naaa\nabc\naba\na*a\naaa*\n*aaa\nSample Output:\n2\n1\n1\nPlease provide the solution as pure code only, without explanations or comments.\n\nANSWER:\n```python\n"}}