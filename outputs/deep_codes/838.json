{"838": {"code": ["from collections import defaultdict\n\ndef count_sets(n, m, table):\n    row_groups = [0] * n\n    col_groups = [0] * m\n    row_dict = defaultdict(list)\n    col_dict = defaultdict(list)\n\n    for i in range(n):\n        for j in range(m):\n            if j > 0 and table[i][j] == table[i][j - 1]:\n                row_groups[i] += 1\n            else:\n                row_groups[i] = 0\n            row_dict[table[i][j]].append(row_groups[i])\n\n    for j in range(m):\n        for i in range(n):\n            if i > 0 and table[i][j", "from collections import Counter\n\ndef solve(n, m, grid):\n    rows = [''.join([str(c) for c in row]) for row in grid]\n    columns = [''.join([str(grid[j][i]) for j in range(n)]) for i in range(m)]\n    counter = Counter(rows + columns)\n    return sum(v * (v - 1) // 2 for v in counter.values())\n\nn, m = map(int, input().split())\ngrid = [list(map(int, input().split())) for _ in range(n)]\nprint(solve(n, m, grid))\n\n\nEXPLANATION:\nThe problem is about finding connected components in a grid. We can solve it by finding the", "from collections import defaultdict\nn, m = map(int, input().split())\nmatrix = [list(map(int, input().split())) for _ in range(n)]\n\nrows = defaultdict(list)\ncols = defaultdict(list)\nfor i in range(n):\n    for j in range(m):\n        if matrix[i][j]:\n            rows[i].append(j)\n        else:\n            cols[j].append(i)\n\ntotal = 0\nfor i in range(n):\n    for j in range(m):\n        if matrix[i][j]:\n            total += len(rows[i]) * len(cols[j])\n\nprint(total)\n\n\nThis program uses a defaultdict to store the indices of the rows", "def solve():\n    n, m = map(int, input().split())\n    grid = [list(map(int, input().split())) for _ in range(n)]\n    dx = [0, 1]\n    dy = [1, 0]\n    visited = [[False]*m for _ in range(n)]\n    def dfs(x, y, color):\n        if x < 0 or y < 0 or x >= n or y >= m or visited[x][y] or grid[x][y] != color:\n            return 0\n        visited[x][y] = True\n        return 1 + sum(dfs(nx, ny, color) for nx, ny in zip([x+dx[i] for i in range(2)],", "import sys\nfrom collections import Counter\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    grid = [list(map(int, sys.stdin.readline().split())) for _ in range(n)]\n\n    rows = [''.join(map(str, row)) for row in grid]\n    columns = [''.join(map(str, column)) for column in zip(*grid)]\n\n    counts = Counter(rows + columns)\n\n    print(sum(count for count in counts.values()))\n\nif __name__ == '__main__':\n    main()\n\nThis solution works by first reading the input and converting it into a grid. It then converts each row and column into a string and counts the occur"], "prompt": "\nQUESTION:\nYou are given n \u00d7 m table. Each cell of the table is colored white or black. Find the number of non-empty sets of cells such that:\n\n  All cells in a set have the same color.  Every two cells in a set share row or column. \n\n\n-----Input-----\n\nThe first line of input contains integers n and m (1 \u2264 n, m \u2264 50)\u00a0\u2014 the number of rows and the number of columns correspondingly.\n\nThe next n lines of input contain descriptions of rows. There are m integers, separated by spaces, in each line. The number equals 0 if the corresponding cell is colored white and equals 1 if the corresponding cell is colored black.\n\n\n-----Output-----\n\nOutput single integer \u00a0\u2014 the number of non-empty sets from the problem description.\n\n\n-----Examples-----\nInput\n1 1\n0\n\nOutput\n1\n\nInput\n2 3\n1 0 1\n0 1 0\n\nOutput\n8\n\n\n\n-----Note-----\n\nIn the second example, there are six one-element sets. Additionally, there are two two-element sets, the first one consists of the first and the third cells of the first row, the second one consists of the first and the third cells of the second row. To sum up, there are 8 sets.\nPlease provide the solution as pure code only, without explanations or comments.\n\nANSWER:\n```python\n"}}