{"2884": {"code": ["class Solution:\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\n        def backtrack(start, target, path):\n            if target == 0:\n                res.append(path)\n                return\n            for i in range(start, len(candidates)):\n                if i > start and candidates[i] == candidates[i - 1]:\n                    continue\n                if candidates[i] > target:\n                    break\n                backtrack(i + 1, target - candidates[i], path + [candidates[i]])\n\n        res = []\n        candidates.sort()\n        backtrack(0, target, [])\n        return res\n\n\n\n\n\nclass Solution:\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\n        def backtrack(start, target, path):", "class Solution:\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\n        def backtrack(start, path, remaining):\n            if remaining < 0:\n                return\n            elif remaining == 0:\n                output.append(path)\n            for i in range(start, len(nums)):\n                if i > start and nums[i] == nums[i - 1]:\n                    continue\n                backtrack(i + 1, path + [nums[i]], remaining - nums[i])\n                \n        output = []\n        nums = sorted(candidates)\n        backtrack(0, [], target)\n        return output\n\n\nThis solution uses backtracking. The `backtrack` function takes a `start` index, a `path` of numbers, and the `remaining` target value. If the `remaining` is less than 0, it returns (", "class Solution:\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\n        candidates.sort()\n        result = []\n        self.dfs(candidates, target, 0, [], result)\n        return result\n\n    def dfs(self, candidates, target, index, path, result):\n        if target < 0:\n            return  # backtracking\n        if target == 0:\n            result.append(path)\n            return \n        for i in range(index, len(candidates)):\n            if i > index and candidates[i] == candidates[i - 1]:\n                continue\n            self.dfs(candidates, target - candidates[i], i + 1, path + [candidates[i]], result)\n\n\nThis solution works by sorting the input candidates first and then using a depth-first search (DFS) to find all possible", "class Solution:\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\n        def backtrack(start, target, path):\n            if target < 0:\n                return  # if over\n            if target == 0:\n                result.append(path)\n                return \n            for i in range(start, len(candidates)):\n                # i > start ensures that we don't count duplicates\n                if i > start and candidates[i] == candidates[i - 1]:\n                    continue\n                # i is used in the path, so start from i+1\n                backtrack(i + 1, target - candidates[i], path + [candidates[i]])\n\n        result = []\n        candidates.sort()\n        backtrack(0, target, [])\n        return result\n\n\n\n\n\n\n\nclass Solution:\n    def combinationSum", "class Solution:\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\n        def dfs(candidates, target, start, path, res):\n            if target < 0:\n                return  # backtracking\n            if target == 0:\n                res.append(path)\n                return \n            for i in range(start, len(candidates)):\n                if i > start and candidates[i] == candidates[i - 1]: continue\n                dfs(candidates, target-candidates[i], i+1, path + [candidates[i]], res)\n\n        candidates.sort()\n        res = []\n        dfs(candidates, target, 0, [], res)\n        return res\n\n\nThis solution uses a Depth First Search (DFS) approach. It starts by sorting the candidates array. Then it recursively tries to find"], "prompt": "\nQUESTION:\nGiven a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates\u00a0where the candidate numbers sums to target.\n\nEach number in candidates\u00a0may only be used once in the combination.\n\nNote:\n\n\n       All numbers (including target) will be positive integers.\n       The solution set must not contain duplicate combinations.\n\n\nExample 1:\n\n\nInput: candidates =\u00a0[10,1,2,7,6,1,5], target =\u00a08,\nA solution set is:\n[\n  [1, 7],\n  [1, 2, 5],\n  [2, 6],\n  [1, 1, 6]\n]\n\n\nExample 2:\n\n\nInput: candidates =\u00a0[2,5,2,1,2], target =\u00a05,\nA solution set is:\n[\n\u00a0 [1,2,2],\n\u00a0 [5]\n]\nSTARTER CODE:\nclass Solution:\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\n        \n\nPlease provide the solution as pure code only, without explanations or comments.\n\nANSWER:\n```python\n"}}