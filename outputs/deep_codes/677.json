{"677": {"code": ["def solve(l, r, d):\n    x = l // d * d\n    if x < l or x > r:\n        return x + d\n    else:\n        return x + d * (d <= r - x)\n\nq = int(input())\nfor _ in range(q):\n    l, r, d = map(int, input().split())\n    print(solve(l, r, d))\n\n\nExplanation:\nThe function `solve` finds the smallest `x` such that `x` is divisible by `d` and `x` does not belong to the segment `[l, r]`. \n\nThe code reads the number of queries `q` from", "q = int(input())\nfor _ in range(q):\n    l, r, d = map(int, input().split())\n    x = l // d + 1\n    if x % d == 0:\n        x += d\n    while x <= r or x % d != 0:\n        x += d\n    print(x)\n\n\nThis code works by first finding the smallest number x that is greater than or equal to l and is divisible by d. Then it checks if x is in the range [l, r] and if it is not, it continues to find the next number that is also divisible by d and not in the range [l, r]. The while loop continues until it finds a number that is not", "def solve(l, r, d):\n    x = l // d * d\n    if x < l:\n        x += d\n    if x >= l and x <= r:\n        x += d\n    return x\n\nq = int(input())\nfor _ in range(q):\n    l, r, d = map(int, input().split())\n    print(solve(l, r, d))\n\n\nEXPLANATION:\nThe problem is asking to find the smallest positive integer `x` such that `x` is divisible by `d` and `x` does not belong to the segment `[l, r]`. \n\nThe solution is to first find the smallest multiple of `d", "def solve():\n    q = int(input())\n    for _ in range(q):\n        l, r, d = map(int, input().split())\n        x = l // d + 1\n        if x <= r:\n            x = (r // d + 1) * d\n        print(x)\n\nsolve()\n\n\nEXPLANATION:\n\nFor each query, we calculate the smallest number x that is divisible by d and is greater than l. We do this by dividing l by d and adding 1. \n\nThen, we check if x is in the range [l, r]. If it is, we increase x until it is not. This is done by dividing r by d and", "def min_non_divisible(l, r, d):\n    x = l % d\n    if x == 0:\n        x += d\n    while x <= r:\n        if x % d == 0:\n            x += d\n        else:\n            return x\n    return -1\n\nq = int(input().strip())\nfor _ in range(q):\n    l, r, d = map(int, input().strip().split())\n    print(min_non_divisible(l, r, d))\n\n\nThis solution works by starting with the smallest number that is divisible by `d` and is greater than or equal to `l`. It then checks each number in the range `l`"], "prompt": "\nQUESTION:\nYou are given $q$ queries in the following form:\n\nGiven three integers $l_i$, $r_i$ and $d_i$, find minimum positive integer $x_i$ such that it is divisible by $d_i$ and it does not belong to the segment $[l_i, r_i]$.\n\nCan you answer all the queries?\n\nRecall that a number $x$ belongs to segment $[l, r]$ if $l \\le x \\le r$.\n\n\n-----Input-----\n\nThe first line contains one integer $q$ ($1 \\le q \\le 500$) \u2014 the number of queries.\n\nThen $q$ lines follow, each containing a query given in the format $l_i$ $r_i$ $d_i$ ($1 \\le l_i \\le r_i \\le 10^9$, $1 \\le d_i \\le 10^9$). $l_i$, $r_i$ and $d_i$ are integers.\n\n\n-----Output-----\n\nFor each query print one integer: the answer to this query.\n\n\n-----Example-----\nInput\n5\n2 4 2\n5 10 4\n3 10 1\n1 2 3\n4 6 5\n\nOutput\n6\n4\n1\n3\n10\nPlease provide the solution as pure code only, without explanations or comments.\n\nANSWER:\n```python\n"}}