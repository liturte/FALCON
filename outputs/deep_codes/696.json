{"696": {"code": ["def phi(n):\n    result = n\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            while n % i == 0:\n                n //= i\n            result -= result // i\n    if n > 1:\n        result -= result // n\n    return result\n\ndef is_primitive_root(p, g):\n    for i in range(1, p):\n        if pow(g, i, p) == 1:\n            return False\n    return True\n\ndef primitive_roots(p):\n    phi_p = phi(p)\n    return [g for g in range(1, p) if is_primitive_root(p, g)]\n\nprint(len(primitive_roots(int(input()))))\n\n\nThis program first calculates the", "def phi(n):\n    result = n\n    p = 2\n    while p * p <= n:\n        if n % p == 0:\n            while n % p == 0:\n                n //= p\n            result -= result // p\n        p += 1\n    if n > 1:\n        result -= result // n\n    return result\n\ndef primitive_root(p):\n    if p == 2:\n        return 1\n    if p % 2 == 0:\n        return 2\n    for g in range(2, p):\n        if phi(p) % (p - 1) == 0:\n            return g\n    return -1\n\np = int(input())\nprint(primitive_root(p))\n\nThis code uses the Euler's totient function (phi) to calculate the number of integers less than p that are relatively prime to", "def primitive_roots(p):\n    def check_primitive(g, p):\n        s = set()\n        for i in range(1, p):\n            s.add(pow(g, i, p))\n            if len(s) == p - 1:\n                return True\n            elif len(s) > p - 1:\n                return False\n        return False\n\n    return sum(check_primitive(g, p) for g in range(1, p))\n\nprint(primitive_roots(int(input())))\n\n\nEXPLANATION:\nThis code uses a Python generator expression to check for primitive roots. The `check_primitive` function checks if `g` is a primitive root modulo `p` by trying all values of `i` from 1 to `p - 1` and checking if `g^i mod p` is in the", "def primitive_roots(p):\n    def is_primitive(n, p):\n        return pow(n, (p - 1) // 2, p) != p - 1\n\n    return sum(is_primitive(n, p) for n in range(1, p))\n\nprint(primitive_roots(int(input())))\n\nThis Python code uses a generator expression to check if each number from 1 to p-1 is a primitive root $\\operatorname{mod} p$. The pow function is used with three arguments, which is a bit faster than pow(n, (p - 1) // 2) % p. The result is the sum of all primitive roots $\\operatorname{mod} p$.\n\nThe pow function with three arguments is used to calculate the value of n^((p-1)//2) mod p. This is equivalent to finding the remainder", "def primitive_root(p):\n    phi = p-1\n    divisors = [1]\n    for i in range(2, int(phi**0.5) + 1):\n        if phi % i == 0:\n            divisors.extend([i, phi//i])\n    divisors = list(set(divisors))\n\n    roots = []\n    for g in range(1, p):\n        if all((pow(g, phi//d, p) - 1) % p != 0 for d in divisors[1:]):\n            if pow(g, phi, p) == 1:\n                roots.append(g)\n    return len(roots)\n\nprint(primitive_root(int(input())))\n\nThis Python code uses the Euler's totient function (phi) and Fermat's little"], "prompt": "\nQUESTION:\nThe cows have just learned what a primitive root is! Given a prime p, a primitive root $\\operatorname{mod} p$ is an integer x (1 \u2264 x < p) such that none of integers x - 1, x^2 - 1, ..., x^{p} - 2 - 1 are divisible by p, but x^{p} - 1 - 1 is. \n\nUnfortunately, computing primitive roots can be time consuming, so the cows need your help. Given a prime p, help the cows find the number of primitive roots $\\operatorname{mod} p$.\n\n\n-----Input-----\n\nThe input contains a single line containing an integer p (2 \u2264 p < 2000). It is guaranteed that p is a prime.\n\n\n-----Output-----\n\nOutput on a single line the number of primitive roots $\\operatorname{mod} p$.\n\n\n-----Examples-----\nInput\n3\n\nOutput\n1\n\nInput\n5\n\nOutput\n2\n\n\n\n-----Note-----\n\nThe only primitive root $\\operatorname{mod} 3$ is 2.\n\nThe primitive roots $\\operatorname{mod} 5$ are 2 and 3.\nPlease provide the solution as pure code only, without explanations or comments.\n\nANSWER:\n```python\n"}}