{"23": {"code": ["def to_max(a, b):\n    a = list(str(a))\n    for i in range(len(a) - 1, -1, -1):\n        for j in range(i - 1, -1, -1):\n            if int(a[j]) > int(a[i]):\n                a[j], a[i] = a[i], a[j]\n                return int(''.join(a)) if int(''.join(a)) <= b else to_max(a, b)\n    return a\n\na = input()\nb = input()\nprint(to_max(a, b))\n\n\nThis solution works by first converting the numbers to lists of their digits. It then iterates over the digits in reverse order, comparing each digit to the next one. If the next digit is larger, it swaps the two digits.", "def max_permutation(a, b):\n    a = list(str(a))\n    n = len(a)\n    for i in range(n - 1, -1, -1):\n        for j in range(i - 1, -1, -1):\n            if int(''.join(a[0:j] + a[i] + a[j:i] + a[j + 1:i] + a[j + 1:])) <= b:\n                a[j], a[i] = a[i], a[j]\n                return int(''.join(a))\n    return int(''.join(a))\n\nprint(max_permutation(int(input()), int(input())))\n\nThis code takes two inputs a and b. It converts a into a list of digits and then goes through the list from right to left. For", "def max_number(a, b):\n    a = list(str(a))\n    b = list(str(b))\n    n = len(a)\n    res = ['0']*n\n    for i in range(n):\n        for j in range(10):\n            if a[i] < str(j) and int(''.join(res[:i] + [str(j)] + res[i+1:])) <= b:\n                res[i] = str(j)\n                break\n    return int(''.join(res))\n\na = int(input())\nb = int(input())\nprint(max_number(a, b))\n\n\nThis code works by iterating through each digit of the number `a` and trying to find the maximum possible value for that digit while ensuring the resulting number doesn't exceed `b`. It does this by iterating", "def max_perm(a, b):\n    a = list(str(a))\n    b = list(str(b))\n    for i in range(len(a)):\n        for j in range(i+1, len(a)):\n            if a[i] < a[j]:\n                a[i], a[j] = a[j], a[i]\n            if int(''.join(a)) <= b:\n                return int(''.join(a))\n    return int(''.join(a))\n\na = int(input())\nb = int(input())\nprint(max_perm(a, b))\n\n\nThis code works by first converting the numbers to lists of characters. It then iterates over the list of characters, comparing each character with the next one. If the next character is larger, it swaps the two characters. This effectively finds the next", "def max_permutation(a, b):\n    a = str(a)\n    b = str(b)\n    a_digits = list(a)\n    b_digits = list(b)\n    n = len(a_digits)\n    for i in range(n-1, -1, -1):\n        for j in range(i-1, -1, -1):\n            if a_digits[j] < a_digits[i] and ''.join(a_digits) < b:\n                a_digits[j], a_digest[i] = a_digits[i], a_digits[j]\n                if int(''.join(a_digits)) > int(b):\n                    a_digits[j], a_digits[i] = a_digits[i], a_digits["], "prompt": "\nQUESTION:\nYou are given two positive integer numbers a and b. Permute (change order) of the digits of a to construct maximal number not exceeding b. No number in input and/or output can start with the digit 0.\n\nIt is allowed to leave a as it is.\n\n\n-----Input-----\n\nThe first line contains integer a (1 \u2264 a \u2264 10^18). The second line contains integer b (1 \u2264 b \u2264 10^18). Numbers don't have leading zeroes. It is guaranteed that answer exists.\n\n\n-----Output-----\n\nPrint the maximum possible number that is a permutation of digits of a and is not greater than b. The answer can't have any leading zeroes. It is guaranteed that the answer exists.\n\nThe number in the output should have exactly the same length as number a. It should be a permutation of digits of a.\n\n\n-----Examples-----\nInput\n123\n222\n\nOutput\n213\n\nInput\n3921\n10000\n\nOutput\n9321\n\nInput\n4940\n5000\n\nOutput\n4940\nPlease provide the solution as pure code only, without explanations or comments.\n\nANSWER:\n```python\n"}}