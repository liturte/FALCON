{"1243": {"code": ["def min_moves(n, boxes):\n    avg = sum(boxes) // n\n    return sum(abs(box - avg) for box in boxes)\n\nn = int(input())\nboxes = list(map(int, input().split()))\nprint(min_moves(n, boxes))\n\nThis solution works by first calculating the desired average number of matches in each box (by dividing the total number of matches by the number of boxes). Then it calculates the total number of moves required by summing the absolute differences between the current number of matches in each box and the desired average.\n\nIt's important to note that the sum of the absolute differences is the total number of moves required, because each move moves a match from one box to an adjacent one. The sum is calculated using a generator expression, which is more efficient than creating a list first.\n\nFinally, the function min_moves is called with the input from the user and the result is printed.\n\nThis solution assumes that the input will be valid, i.e., that the number of matches is divisible by the number of boxes, and that the numbers of matches in the boxes are non-negative and do not exceed 10^9.", "def min_moves(n, matches):\n    avg = sum(matches) // n\n    return sum(abs(m - avg) for m in matches)\n\nn = int(input())\nmatches = list(map(int, input().split()))\nprint(min_moves(n, matches))\n\n\nThis solution works by first calculating the average number of matches that each box should have, which is the total number of matches divided by the number of boxes. Then, it calculates the minimum number of moves required to achieve this configuration by summing the absolute difference between the current number of matches in each box and the average number of matches.\n\nThis solution runs in O(n) time, because it needs to iterate over each box once to calculate the average number of matches and once more to calculate the total number of moves. The space complexity is O(n), because it stores the number of matches in each box.\n\nPlease note that the input and output format is not specified in the problem, so this solution assumes that the input is provided in the format described in the problem statement.\n\nAlso, please note that the provided solution is in Python language. If you want a solution in different programming language, you will need to modify the code accordingly", "def min_moves(n, boxes):\n    avg = sum(boxes) // n\n    return sum(abs(box - avg) for box in boxes)\n\nn = int(input())\nboxes = list(map(int, input().split()))\nprint(min_moves(n, boxes))\n\n\nExplanation:\nThe solution first calculates the average number of matches per box, which is achieved by summing up all matches and dividing by the number of boxes.\nThen, for each box, it calculates the number of moves required to bring the matches to the average number of matches per box, which is achieved by taking the absolute difference between the current number of matches in the box and the average. This is summed up for all boxes to get the total number of moves.\n'''\n\n# Solution:\n\nn = int(input())\nboxes = list(map(int, input().split()))\n\navg = sum(boxes) // n\nmoves = sum(abs(box - avg) for box in boxes)\n\nprint(moves)\n\nThis solution works by first calculating the average number of matches per box. Then, for each box, it calculates", "n = int(input())\nboxes = list(map(int, input().split()))\navg = sum(boxes) // n\nmoves = 0\nfor box in boxes:\n    moves += abs(box - avg)\nprint(moves // 2)\n\n\nEXPLANATION:\nThe solution is based on the fact that Petya can move a match from its box to the adjacent one in one move. So, to achieve the desired configuration, we need to make sure that the average number of matches in all boxes is the same. We calculate the average number of matches and then for each box, we add the absolute difference between the current number of matches and the average to the total number of moves. Finally, we divide the total number of moves by 2 because each move involves moving a match from one box to another, and we only count each move once.\n\nPlease note that the time complexity of this solution is O(n), where n is the number of matchboxes. This is because we iterate over the list of matchboxes once to calculate the average number of matches and once more to calculate the total number of moves.", "n = int(input())\nboxes = list(map(int, input().split()))\navg = sum(boxes) // n\nmoves = 0\nfor box in boxes:\n    moves += abs(box - avg)\nprint(moves // 2)\n\n\nThis code first calculates the average number of matches per box. It then goes through each box, adding the absolute difference between the current box's number of matches and the average to a total moves count. Since each move involves moving a match from one box to an adjacent one, the total moves count is divided by 2 to get the minimum number of moves."], "prompt": "\nQUESTION:\nPetya has k matches, placed in n matchboxes lying in a line from left to right. We know that k is divisible by n. Petya wants all boxes to have the same number of matches inside. For that, he can move a match from its box to the adjacent one in one move. How many such moves does he need to achieve the desired configuration?\n\n\n-----Input-----\n\nThe first line contains integer n (1 \u2264 n \u2264 50000). The second line contains n non-negative numbers that do not exceed 10^9, the i-th written number is the number of matches in the i-th matchbox. It is guaranteed that the total number of matches is divisible by n.\n\n\n-----Output-----\n\nPrint the total minimum number of moves.\n\n\n-----Examples-----\nInput\n6\n1 6 2 5 3 7\n\nOutput\n12\nPlease provide the solution as pure code only, without explanations or comments.\n\nANSWER:\n```python\n"}}