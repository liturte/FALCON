{"3384": {"code": ["def closest_handsome(n):\n    n = str(n)\n    if len(n) == 1:\n        return n*2\n    min_diff = float('inf')\n    min_nums = []\n    for i in range(len(n)-1):\n        for j in range(i+1, len(n)):\n            num1 = int(n[:i] + str(1-int(n[i])) + n[i+1:j] + str(1-int(n[j])) + n[j+1:])\n            num2 = int(n[:i] + str(1-int(n[i])) + n[i+1:j] + str(1-int(n[j])) + n[j+1:]) + 1\n            for num in (num1, num2):\n                if num != n and all(int(x) ^ int(y) for x, y in zip(str(num)[:-1], str(num)[1:])):\n                    diff = abs(num - int(n))\n                    if diff < min_diff:\n                        min_diff = diff\n                        min_nums = [num]\n                    elif diff == min_diff:\n                        min_nums.append(num)\n    return ' '.join(map(str, sorted(min_nums)))\n\nprint(closest_hands", "def next_num(s, i):\n    if i == 0:\n        return '9' + s[1:]\n    elif s[i] == '9':\n        return next_num(s, i-1)\n    else:\n        return s[:i] + str(int(s[i])+1) + '0' + s[i+1:]\n\ndef prev_num(s, i):\n    if i == 0:\n        return '1' + s[1:]\n    elif s[i] == '1':\n        return prev_num(s, i-1)\n    else:\n        return s[:i] + str(int(s[i])-1) + '0' + s[i+1:]\n\ndef is_beautiful(s):\n    for i in range(len(s)-1):\n        if abs(int(s[i])-int(s[i+1])) != 1:\n            return False\n    return True\n\nN = input()\nif is_beautiful(N):\n    print(N)\nelse:\n    n1 = N\n    while not is_beautiful(n1):\n        n1 = next_num(n1, len(n1)-1)\n    n2 = N\n    while not is_beautiful(n2):\n        n2 = prev_num(n2, len(n2", "def is_beautiful(n):\n    n = str(n)\n    for i in range(len(n) - 1):\n        if abs(int(n[i]) - int(n[i+1])) != 1:\n            return False\n    return True\n\ndef closest_beautiful(n):\n    n = int(n)\n    m1, m2 = n - 1, n + 1\n    while not is_beautiful(m1):\n        m1 -= 1\n    while not is_beautiful(m2):\n        m2 += 1\n    return m1, m2\n\nprint(*closest_beautiful(input()))\n\n\nEXPLANATION:\nThe problem requires to find the closest two numbers to the given number which are \"beautiful\" numbers. A number is considered beautiful if all its consecutive digits have different parity. \n\nThe given number is converted to a string to access individual digits easily. Then, we check for each digit if it differs from the next one by 1 in absolute value. If not, the number is not beautiful.\n\nTo find the closest beautiful numbers, we start from the given number and decrement and increment it by 1 until we find a beautiful number. The beautiful numbers are returned as a tuple.\n\nThe '*' operator is used to unpack the tuple returned by closest_beautiful function and print its elements separated by a space.\n\nThe input is taken as", "def closest_handsome(n):\n    n = str(n)\n    digits = [int(x) for x in n]\n    results = []\n    for i in range(len(digits)-1):\n        if digits[i] % 2 == digits[i+1] % 2:\n            for j in range(1, 10):\n                if j != digits[i] and j != digits[i+1]:\n                    new_num = int(n[:i] + str(j) + n[i+1:])\n                    results.append(new_num)\n    return min(results, key=lambda x: (abs(x - n), x))\n\nn = int(input())\nprint(*closest_handsome(n))\n\n\nThis code works by first converting the input number to a string and a list of its digits. It then iterates over each pair of consecutive digits. If the digits have the same parity, it tries to replace them with two different digits that have different parity. It calculates the new number by concatenating the digits before the pair, the new digit, and the digits after the pair. It then appends the new number to a list of results. Finally, it returns the number with the smallest difference from the input number and the smallest value.\n\nPlease note that this code assumes that the input number is", "def closest_handsome(n):\n    n = str(n)\n    lower = int(n) - 1\n    while bin(lower).count('1') != len(bin(lower)) - 1 or not all(int(i) % 2 != int(j) % 2 for i, j in zip(str(lower), str(lower)[1:])):\n        lower -= 1\n    upper = int(n) + 1\n    while bin(upper).count('1') != len(bin(upper)) - 1 or not all(int(i) % 2 != int(j) % 2 for i, j in zip(str(upper), str(upper)[1:])):\n        upper += 1\n    if abs(int(n) - lower) <= abs(int(n) - upper):\n        return lower, int(n) + 1 if abs(int(n) - lower) == abs(int(n) - upper) else None\n    else:\n        return int(n) - 1, upper\n\nprint(*closest_handsome(int(input())))\n\nThis Python program first defines a function `closest_handsome` that calculates the closest handsome numbers to a given input `n`. It then prints the closest handsome numbers to the input number.\n\nThe `bin` function is used to check the binary representation of numbers to ensure"], "prompt": "\nQUESTION:\nAn integer is considered handsome if every two of its consecutive digits are of different parity. For a given integer $N$, what is its closest handsome number?\n\nPlease note: numbers consisting of only one digit are handsome numbers. The distance of two numbers is the absolute value of their difference.\n\n-----Input-----\nThe first and only line of input contains a positive integer $N$ that consists of at most thousand digits and is not handsome.\n\n-----Output-----\nThe first and only line of output must contain the required closest handsome number. If two closest numbers exist, output the smaller number first and then the larger one and separate them by a single space.\n\n-----Examples-----\nSample Input:\n13\nSample Output:\n12 14\nPlease provide the solution as pure code only, without explanations or comments.\n\nANSWER:\n```python\n"}}