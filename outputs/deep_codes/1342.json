{"1342": {"code": ["def min_sets(n, a):\n    return sum(a[i]//2 + (a[i]+1)%2 for i in range(n))\n\nn = int(input())\na = list(map(int, input().split()))\nprint(min_sets(n, a))\n\n\nExplanation:\nThe minimum number of sets is the sum of the minimum number of sets for each color.\nEach color can be divided into sets of size 2 if possible, but if there are odd number of balls of that color, one ball has to be left out.\nSo for each color, we divide the number of balls by 2 and add 1 if there are odd number of", "import heapq\n\nn = int(input().strip())\na = list(map(int, input().strip().split()))\n\na.sort()\n\nres = 0\nwhile a:\n    # Take the two smallest elements and subtract their difference\n    # from the remaining elements. If the difference is negative,\n    # there's no need to subtract anything.\n    x = a.pop(0)\n    y = a[0] if a else 0\n    diff = x - y\n    a = [i - diff for i in a]\n    # Remove elements that are less than or equal to zero\n    while a and a[0] <= 0:\n        a.pop(", "def min_sets(n, a):\n    a.sort(reverse=True)\n    sets = [a[0]]\n    for i in range(1, n):\n        if a[i] < len(sets):\n            sets[a[i]] = a[i]\n        else:\n            sets.append(a[i])\n    return len(sets)\n\nn = int(input())\na = list(map(int, input().split()))\nprint(min_sets(n, a))\n\n\nThis Python program sorts the input array in descending order and then iterates through it. For each element, it tries to place it into an existing set with the same color", "n = int(input())\nballs = list(map(int, input().split()))\n\nballs.sort(reverse=True)\nmax_balls = max(balls)\n\nsets = [0] * max_balls\n\nfor i in range(n):\n    for j in range(balls[i]):\n        while sets[j] == 1:\n            j += 1\n        sets[j] = 1\n\nprint(sum(sets))\n\n\nThis code first sorts the balls in descending order. Then it creates a list of zeros with length equal to the maximum number of balls. For each ball, it tries to find a place in the list where it can", "import heapq\n\ndef min_sets(n, a):\n    heap = [-x for x in a]\n    heapq.heapify(heap)\n    sets = 0\n    while heap:\n        x = -heapq.heappop(heap)\n        if heap and heap[0] < -1:\n            y = -heapq.heappop(heap)\n            heapq.heappush(heap, y+1)\n        sets += 1\n    return sets\n\nn = int(input())\na = list(map(int, input().split()))\nprint(min_sets(n, a))\n\n\nThis code uses a"], "prompt": "\nQUESTION:\nThere are n boxes with colored balls on the table. Colors are numbered from 1 to n. i-th box contains a_{i} balls, all of which have color i. You have to write a program that will divide all balls into sets such that:  each ball belongs to exactly one of the sets,  there are no empty sets,  there is no set containing two (or more) balls of different colors (each set contains only balls of one color),  there are no two sets such that the difference between their sizes is greater than 1. \n\nPrint the minimum possible number of sets.\n\n\n-----Input-----\n\nThe first line contains one integer number n (1 \u2264 n \u2264 500).\n\nThe second line contains n integer numbers a_1, a_2, ... , a_{n} (1 \u2264 a_{i} \u2264 10^9).\n\n\n-----Output-----\n\nPrint one integer number \u2014 the minimum possible number of sets.\n\n\n-----Examples-----\nInput\n3\n4 7 8\n\nOutput\n5\n\nInput\n2\n2 7\n\nOutput\n4\n\n\n\n-----Note-----\n\nIn the first example the balls can be divided into sets like that: one set with 4 balls of the first color, two sets with 3 and 4 balls, respectively, of the second color, and two sets with 4 balls of the third color.\nPlease provide the solution as pure code only, without explanations or comments.\n\nANSWER:\n```python\n"}}