{"3665": {"code": ["def", "def", "n", "def", "def"], "prompt": "\nQUESTION:\nArranging Hat is a cushy job indeed; high impact work, absolute authority, and 364 days of holiday every year. However, the hat has decided that it can do even better\u2014it would like very much to become a tenured professor. \n\nRecently the hat has been reading computer science papers in its ample spare time, and of course, being an arranging hat, it is particularly interested in learning more about sorting algorithms.\n\nThe hat\u2019s new contribution is to a class of algorithms known as lossy sorting algorithms. These usually work by removing some of the input elements in order to make it easier to sort the input (e.g., the Dropsort algorithm), instead of sorting all the input.\n\nThe hat is going to go one better\u2014it is going to invent a lossy sorting algorithm for numbers that does not remove any input numbers and even keeps them in their original place, but instead changes some of the digits in the numbers to make the list sorted.\n\nThe lossiness of the sorting operation depends on how many digits are changed. What is the smallest number of digits that need to be changed in one such list of numbers, to ensure that it is sorted?\n\n-----Input-----\nThe input consists of:\n - one line containing the integers $n$ and $m$ ($1 \\le n \\le 40$, $1 \\le m \\le 400$), the number of numbers and the number of digits in each number, respectively.\n - $n$ lines each containing an integer $v$ ($0 \\le v < 10^{m}$). The numbers are zero-padded to exactly $m$ digits.\n\n-----Output-----\nWrite a sorted version of the array, after making a minimum number of digit changes to make the numbers sorted (the numbers must remain zero-padded to $m$ digits). If there are multiple optimal solutions, you may give any of them.\n\n-----Examples-----\nSample Input:\n5 3\n111\n001\n000\n111\n000\nSample Output:\n001\n001\n001\n111\n200\nPlease provide the solution as pure code only, without explanations or comments.\n\nANSWER:\n```python\n"}}