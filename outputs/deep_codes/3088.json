{"3088": {"code": ["def max_number(n, k):\n    n = list(str(n))\n    for i in range(len(n)):\n        for j in range(i+1, len(n)):\n            if k == 0:\n                break\n            if n[i] < n[j]:\n                n[i], n[j] = n[j], n[i]\n                k -= 1\n    return ''.join(n)\n\nn, k = map(int, input().split())\nprint(max_number(n, k))\n\n\nThis code works by iterating through the digits of the number and trying to find pairs of digits where the first one is smaller than the second one. If it finds such a pair, it swaps them and decreases the number of remaining swaps. The function returns the number as a string after performing all possible swaps.\n\nThe time complexity of this code is O(n^2) because in the worst case scenario, it will iterate through the number of digits squared times. The space complexity is O(n) because it stores the digits of the number as a list.\n\nPlease note that this code assumes that the input is always valid and does not check for edge cases like leading zeros.", "def largest_number(n, k):\n    n = list(str(n))\n    for i in range(k):\n        for j in range(len(n) - 1):\n            if n[j] < n[j + 1]:\n                n[j], n[j + 1] = n[j + 1], n[j]\n                break\n            elif n[j] == n[j + 1] and n[0] != '0':\n                n[j], n[j + 1] = n[j + 1], n[j]\n                break\n    return ''.join(n)\n\nprint(largest_number(int(input().split()[0]), int(input().split()[1])))\n\n\nThis solution works by converting the number to a list of digits, then performing swaps between digits. The swap is performed in a way that the first digit that is smaller than the next one is swapped with it. If the digits are equal, and the first digit is not a '0', they are also swapped. This is done for $k$ times. The result is then joined back into a string and returned.\n\nNote that this solution assumes that the input will always be valid and that the", "from collections import deque\n\ndef max_number(n, k):\n    n = list(str(n))\n    stack = deque()\n    for i in range(len(n)):\n        while k > 0 and stack and stack[-1] < n[i]:\n            stack.pop()\n            k -= 1\n        stack.append(n[i])\n    return int(\"\".join(stack[:len(n) - k]))\n\nn, k = map(int, input().split())\nprint(max_number(n, k))\n\nThis Python code uses a stack to track the maximum number seen so far. It iterates over the digits of the number, and for each digit, it tries to pop the stack if it's larger than the current digit. If the number of pops is less than `k`, it keeps popping. The rest of the digits are appended to the stack in their original order. The maximum number is then formed by joining the remaining elements in the stack.\n\nThis solution works by always trying to make the largest possible number by swapping the largest unprocessed digit with the current digit. This ensures that the final number will be the maximum possible number.\n\nPlease note that the number of swaps used can be less", "def max_number(n, k):\n    n = list(str(n))\n    for i in range(len(n)):\n        for j in range(i + 1, len(n)):\n            if k == 0:\n                break\n            if n[i] > n[j]:\n                n[i], n[j] = n[j], n[i]\n                k -= 1\n    return int(''.join(n))\n\nn, k = map(int, input().split())\nprint(max_number(n, k))\n\nThis Python solution uses a simple greedy approach to solve the problem. It converts the input number to a list of digits, then iterates through the list, swapping each digit with every subsequent digit if the current digit is greater than the subsequent digit. The swaps are performed until no more swaps are possible or the number of remaining swaps is zero. The solution then converts the list of digits back to a number and returns it.\n\nThe time complexity of this solution is O(n^2), where n is the number of digits in the input number. This is because in the worst case, we might have to swap each digit with every other digit. The space complexity is O(n), for", "def largest_number(n, k):\n    n = list(str(n))\n    for i in range(k):\n        for j in range(len(n) - 1):\n            if n[j] < n[j+1]:\n                n[j], n[j+1] = n[j+1], n[j]\n                break\n        else:\n            continue\n        break\n    return int(''.join(n))\n\nn, k = map(int, input().split())\nprint(largest_number(n, k))\n\n\nExplanation:\nThis solution works by iteratively swapping adjacent digits in the number if the left digit is smaller than the right one. This is done up to $k$ times. The number is then returned as an integer.\n\nThe time complexity of this solution is O(n*k) where n is the number of digits in the number and k is the number of swaps. This is because for each swap, we potentially need to iterate over all the digits in the number. The space complexity is O(n) because we store the digits of the number as a list.\n\nThe given constraints ($100 \\leq n < 10^{18}$"], "prompt": "\nQUESTION:\nYou are given a positive integer $n$ and asked to make it larger by swapping pairs of its digits. For each swap, you can choose two digits at different positions and exchange their positions, as long as the swap does not result in a leading zero. What is the largest number you can get after performing exactly $k$ swaps?\n\n-----Input-----\nThe input has a single line with two integers $n$ ($100 \\leq n < 10^{18}$) and $k$ ($1 \\leq k \\leq 18$).\n\n-----Output-----\nOutput the largest number you can get after exactly $k$ swaps.\n\n-----Examples-----\nSample Input 1:\n1374 2\nSample Output 1:\n7413\n\nSample Input 2:\n210 1\nSample Output 2:\n201\nPlease provide the solution as pure code only, without explanations or comments.\n\nANSWER:\n```python\n"}}