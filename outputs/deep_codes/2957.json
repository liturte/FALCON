{"2957": {"code": ["import heapq\n\ndef shortest_path(n, k):\n    graph = [[] for _ in range(n)]\n    for v in range(n):\n        if v + 1 < n:\n            graph[v].append((v + 1, 1))\n        w = k\n        while w < n:\n            graph[v].append((w, 1))\n            w *= k\n            \n    distances = [float('inf')] * n\n    distances[0] = 0\n    queue = [(0, 0)]\n    while queue:\n        dist, node = heapq.heappop(queue)\n        if dist != distances[node]:\n            continue\n        for neighbor, weight in graph[node]:\n            alt = dist + weight\n            if alt < distances[neighbor]:\n                distances[neighbor", "import heapq\n\ndef shortest_path(n, K):\n    graph = [[] for _ in range(n)]\n    for i in range(1, n):\n        if i % K == 0:\n            graph[i].append((i // K, 1))\n            graph[i // K].append((i, 1))\n        else:\n            graph[i].append((i - 1, 1))\n            graph[i - 1].append((i, 1))\n\n    distances = [float('inf')] * n\n    distances[0] = 0\n    heap = [(0, 0)]\n    while heap:\n        dist, node = heapq.heappop(heap)\n        if dist > distances[node]:\n            continue\n        for next_node, next_dist in graph[", "from heapq import heappop, heappush\n\ndef shortest_path(n, K):\n    visited = [0]*n\n    heap = [(0, 0)]\n    while heap:\n        d, node = heappop(heap)\n        if node == n-1:\n            return d\n        if visited[node]:\n            continue\n        visited[node] = 1\n        for next_node in (node+1, node-1, node//K):\n            if 0 <= next_node < n and not visited[next_node]:\n                heappush(heap, (d+1, next_node))\n\nn, K = map(int, input().split())\nprint(shortest_path(n, K))\n\n\nExplanation:\nThis Python solution uses a modified version of", "import heapq\n\ndef shortest_path(n, K):\n    graph = [[] for _ in range(n)]\n    for i in range(n):\n        if i+1 < n:\n            graph[i].append((i+1, 1))\n        j = 2\n        while i*j < n:\n            graph[i].append((i*j, 1))\n            j += 1\n    for i in range(n):\n        if i*K < n:\n            graph[i].append((i*K, 1))\n    dist = [float('inf')] * n\n    dist[0] = 0\n    heap = [(0, 0)]\n    while heap:\n        d, node = heapq.heappop(heap)\n        if d > dist[node]:\n            continue", "from heapq import heappop, heappush\n\ndef shortest_path(n, k):\n    visited = [0]*n\n    heap = [(0, 0)]\n    while heap:\n        d, node = heappop(heap)\n        if node == n-1:\n            return d\n        if visited[node]:\n            continue\n        visited[node] = 1\n        for next_node in [node+1, node*k]:\n            if next_node < n:\n                heappush(heap, (d+1, next_node))\n\nn, k = map(int, input().split())\nprint(shortest_path(n, k))\n\n\nThis Python code uses a priority queue (heapq) to keep track of the nodes to visit. It starts at node 0"], "prompt": "\nQUESTION:\nL\u00f6pkass is out running in the forest again. He loves running in the forest. However, there is a programming competition starting in a couple of hours, and he needs to calculate how long it will take him to get home (so that he can stay in the fresh air as long as possible). You have to help him out.\n\nThe forest is modelled as a graph with $n$ nodes. Nodes are numbered $0, 1, ..., n-1$. L\u00f6pkass is located in node $0$, and his home is located in node $n-1$. Two nodes $v,w$ are connected if $v+1 = w$. Additionally, two nodes are connected if they are both a multiple of some integer $K$. In this problem, we do not consider $0$ to be a multiple of $K$.\n\n-----Input-----\nOne line with two integers, the number of nodes $1 \\leq n \\leq 10^{18}$, and the number $1 \\leq K \\leq 10^{18}$.\n\n-----Output-----\nPrint a single integer on a single line: the shortest path from node 0 to node $n-1$.\n\n-----Examples-----\nSample Input:\n5 2\nSample Output:\n3\nPlease provide the solution as pure code only, without explanations or comments.\n\nANSWER:\n```python\n"}}