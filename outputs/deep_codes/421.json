{"421": {"code": ["def max_orders():\n    n = int(input().strip())\n    intervals = []\n    for _ in range(n):\n        l, r = map(int, input().strip().split())\n        intervals.append((l, r))\n    intervals.sort(key=lambda x: (x[1], -x[0]))  # sort by finish time, then by start time\n\n    prev_r = -1\n    count = 0\n    for l, r in intervals:\n        if l >= prev_r:\n            prev_r = r\n            count += 1\n    return count\n\nprint(max_orders())\n\nThis code reads the input, sorts the intervals by their finish time", "n = int(input())\norders = [list(map(int, input().split())) for _ in range(n)]\norders.sort(key=lambda x: (x[1], x[0]))\n\nend = 0\ncnt = 0\nfor order in orders:\n    if order[0] >= end:\n        cnt += 1\n        end = order[1]\nprint(cnt)\n\nThis code first reads the number of orders and the orders themselves. It then sorts the orders by their finish time and then their start time. It then iterates over the sorted orders and checks if the start time of the current order is greater than or equal to the end time of the last accepted order. If it is", "import sys\n\ndef max_orders(orders):\n    # Sort the orders by finish time\n    orders.sort(key=lambda x: x[1])\n    # Initialize the first order as the best\n    best = orders[0]\n    count = 1\n    # Iterate over the rest of the orders\n    for order in orders[1:]:\n        # If the start time of the current order is after the finish time of the best order, update the best order and increment the count\n        if order[0] >= best[1]:\n            best = order\n            count += 1\n    return count\n\nn = int(sys.stdin.readline())\norders = [tuple(map(int", "def max_orders():\n    n = int(input())\n    orders = [list(map(int, input().split())) for _ in range(n)]\n    orders.sort(key=lambda x: (x[1], x[0]))\n    end = 0\n    count = 0\n    for order in orders:\n        if order[0] >= end:\n            count += 1\n            end = order[1]\n    return count\n\nprint(max_orders())\n\nThis solution works by first sorting the orders by their finish time (primary key) and start time (secondary key). Then, it iterates through the sorted list of orders, and for each order, it checks if its start time is greater", "import sys\n\ndef max_orders():\n    n = int(sys.stdin.readline().strip())\n    intervals = []\n    for _ in range(n):\n        l, r = map(int, sys.stdin.readline().strip().split())\n        intervals.append((l, r))\n    intervals.sort(key=lambda x: (x[1], x[0]))\n    end, cnt = -1, 0\n    for interval in intervals:\n        if interval[0] >= end:\n            end = interval[1]\n            cnt += 1\n    print(cnt)\n\nmax_orders()\n\nThis code first reads the number of orders and"], "prompt": "\nQUESTION:\nA restaurant received n orders for the rental. Each rental order reserve the restaurant for a continuous period of time, the i-th order is characterized by two time values \u2014 the start time l_{i} and the finish time r_{i} (l_{i} \u2264 r_{i}).\n\nRestaurant management can accept and reject orders. What is the maximal number of orders the restaurant can accept?\n\nNo two accepted orders can intersect, i.e. they can't share even a moment of time. If one order ends in the moment other starts, they can't be accepted both.\n\n\n-----Input-----\n\nThe first line contains integer number n (1 \u2264 n \u2264 5\u00b710^5) \u2014 number of orders. The following n lines contain integer values l_{i} and r_{i} each (1 \u2264 l_{i} \u2264 r_{i} \u2264 10^9).\n\n\n-----Output-----\n\nPrint the maximal number of orders that can be accepted.\n\n\n-----Examples-----\nInput\n2\n7 11\n4 7\n\nOutput\n1\n\nInput\n5\n1 2\n2 3\n3 4\n4 5\n5 6\n\nOutput\n3\n\nInput\n6\n4 8\n1 5\n4 7\n2 5\n1 3\n6 8\n\nOutput\n2\nPlease provide the solution as pure code only, without explanations or comments.\n\nANSWER:\n```python\n"}}