{"1366": {"code": ["n = int(input())\nbottles = [list(map(int, input().split())) for _ in range(n)]\nbottles.sort()\n\nnot_opened = set(range(1, 1001))\n\nfor a, b in bottles:\n    if a in not_opened:\n        not_opened.remove(a)\n    if b in not_opened:\n        not_opened.remove(b)\n\nprint(len(not_opened))\n\n\nThis solution works by first sorting the list of bottles by their first element. Then it iterates over the sorted list of bottles, removing each bottle's", "n = int(input())\nbrands = set()\nunopened_bottles = 0\nfor _ in range(n):\n    a, b = map(int, input().split())\n    if a not in brands:\n        brands.add(a)\n    elif b not in brands:\n        brands.add(b)\n    else:\n        unopened_bottles += 1\nprint(unopened_bottles)\n\n\nThis code reads the number of bottles and their descriptions from the input. It keeps track of the brands of bottles that have been opened so far in a set. If a new brand is encountered, it is added to the set. If", "n = int(input())\nbottles = [list(map(int, input().split())) for _ in range(n)]\nbottles.sort(key=lambda x: (x[0], -x[1]))\n\nunopenable = 0\nlast_opened = -1\nfor a, b in bottles:\n    if a != b:\n        if last_opened < a:\n            unopenable += 1\n        else:\n            last_opened = min(last_opened, b)\n\nprint(unopenable)\n\nThis Python solution sorts the bottles by their brand a_i and by their capacity b_i in descending order", "n = int(input())\nbrands = set()\nfor _ in range(n):\n    a, b = map(int, input().split())\n    if a == b:\n        brands.add(a)\nprint(n - len(brands))\n\n\nThis code works by first reading the number of bottles from the input. It then iterates over each bottle, reading its a and b values. If a and b are the same, it adds that value to a set of brands. Finally, it prints the number of bottles minus the size of the set, which is the number of bottles that cannot be opened.\n\nThis solution assumes that a brand can be opened by itself (i.e", "n = int(input())\nbottles = [list(map(int, input().split())) for _ in range(n)]\nbrands = [bottles[i][0] for i in range(n)]\nbrands += [bottles[i][1] for i in range(n)]\nprint(n - len(set(brands)))\n\n\nEXPLANATION:\nThe solution is based on the observation that if a bottle can be opened by another bottle, then they must have the same brand. Therefore, we can just count the number of unique brands and subtract it from the total number of bottles. The number of bottles that cannot be opened is the total number of bottles"], "prompt": "\nQUESTION:\nSereja and his friends went to a picnic. The guys had n soda bottles just for it. Sereja forgot the bottle opener as usual, so the guys had to come up with another way to open bottles.\n\nSereja knows that the i-th bottle is from brand a_{i}, besides, you can use it to open other bottles of brand b_{i}. You can use one bottle to open multiple other bottles. Sereja can open bottle with opened bottle or closed bottle.\n\nKnowing this, Sereja wants to find out the number of bottles they've got that they won't be able to open in any way. Help him and find this number.\n\n\n-----Input-----\n\nThe first line contains integer n (1 \u2264 n \u2264 100) \u2014 the number of bottles. The next n lines contain the bottles' description. The i-th line contains two integers a_{i}, b_{i} (1 \u2264 a_{i}, b_{i} \u2264 1000) \u2014 the description of the i-th bottle.\n\n\n-----Output-----\n\nIn a single line print a single integer \u2014 the answer to the problem.\n\n\n-----Examples-----\nInput\n4\n1 1\n2 2\n3 3\n4 4\n\nOutput\n4\n\nInput\n4\n1 2\n2 3\n3 4\n4 1\n\nOutput\n0\nPlease provide the solution as pure code only, without explanations or comments.\n\nANSWER:\n```python\n"}}