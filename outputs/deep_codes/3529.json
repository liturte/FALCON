{"3529": {"code": ["def main():\n    n, m, k = map(int, input().split())\n    graph = [[] for _ in range(n+1)]\n    for _ in range(m):\n        c, f, t = input().split()\n        f, t = int(f), int(t)\n        graph[f].append((t, c))\n        graph[t].append((f, c))\n    visited = [False] * (n+1)\n    blue_edges = 0\n    def dfs(node):\n        nonlocal blue_edges", "from collections import defaultdict\n\ndef find(x, parent):\n    if parent[x] != x:\n        parent[x] = find(parent[x], parent)\n    return parent[x]\n\ndef union(x, y, parent, rank):\n    xr = find(x, parent)\n    yr = find(y, parent)\n    if rank[xr] < rank[yr]:\n        parent[xr] = yr\n    elif rank[yr] < rank[xr]:\n        parent[yr] = xr\n    else:\n        parent[", "def union_find(parent, x):\n    if parent[x] != x:\n        parent[x] = union_find(parent, parent[x])\n    return parent[x]\n\ndef kruskal(graph, k):\n    parent = list(range(len(graph)+1))\n    blue_edges = 0\n    total_cost = 0\n    for edge in sorted(graph, key=lambda x: x[2]):\n        c, f, t = edge\n        if union_find(parent, f) != union_find(parent", "import sys\nfrom collections import defaultdict\nfrom heapq import *\n\ndef read_int():\n    return int(sys.stdin.readline())\n\ndef read_ints():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef solve():\n    n, m, k = read_ints()\n    edges = [read_ints() for _ in range(m)]\n    graph = defaultdict(list)\n    for c, u, v in edges:\n        graph[u].append((v, c))\n        graph[v].append", "from collections import defaultdict\n\ndef find(parent, i):\n    if parent[i] == i:\n        return i\n    return find(parent, parent[i])\n\ndef union(parent, rank, x, y):\n    xroot = find(parent, x)\n    yroot = find(parent, y)\n    if rank[xroot] < rank[yroot]:\n        parent[xroot] = yroot\n    elif rank[xroot] > rank[yroot]:\n        parent[yroot] = xroot\n    else:\n        parent[yroot"], "prompt": "\nQUESTION:\nGiven an undirected, unweighted, connected graph, where each edge is colored either blue or red, determine whether a spanning tree with exactly $k$ blue edges exists.\n\n-----Input-----\nThere will be a single test case in the input. Each test case will begin with a line with three integers:\n\n$n \\ m \\ k$\n\nWhere $n$ ($2 \\le n \\le 1000$) is the number of nodes in the graph, $m$ (limited by the structure of the graph) is the number of edges in the graph, and $k$ ($0 \\le k < n$) is the number of blue edges desired in the spanning tree. Each of the next $m$ lines will contain three elements, describing the edges:\n\n$c \\ f \\ t$\n\nWhere $c$ is a character, either capital R or capital B, indicating the color of the edge, and $f$ and $t$ are integers ($1 \\le f, t \\le n, t \\ne f$) indicating the nodes that edge goes from and to. The graph is guaranteed to be connected, and there is guaranteed to be at most one edge between any pair of nodes.\n\n-----Output-----\nOutput a single line, containing $1$ if it is possible to build a spanning tree with exactly $k$ blue edges, and $0$ if it is not possible.\n\n-----Examples-----\nSample Input:\n3 3 2\nB 1 2\nB 2 3\nR 3 1\nSample Output:\n1\nPlease provide the solution as pure code only, without explanations or comments.\n\nANSWER:\n```python\n"}}