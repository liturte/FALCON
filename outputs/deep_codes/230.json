{"230": {"code": ["N = int(input())\nS = input()\n\ndef solve(N, S):\n    ans = 0\n    for len in range(1, N):\n        dp = [0] * (N - len + 1)\n        for i in range(N - len):\n            if S[i] == S[i + len]:\n                if i + len + 1 <= N - 1 and dp[i + len + 1] > 0:\n                    dp[i] = dp[i + len + 1] + 1\n                else:\n                    d", "N = int(input())\nS = input()\n\ndef solve(N, S):\n    ans = 0\n    for len in range(1, N):\n        seen = set()\n        for i in range(N - len + 1):\n            sub = S[i:i+len]\n            if sub in seen:\n                ans = max(ans, len)\n            seen.add(sub)\n    return ans\n\nprint(solve(N, S))\n\n\nThis solution works by iterating over all possible lengths of substrings to check for", "N = int(input())\nS = input()\n\ndef solve(s):\n    n = len(s)\n    res = 0\n    for len_ in range(1, n // 2 + 1):\n        if n % len_ != 0: continue\n        cnt = n // len_\n        found = True\n        for start in range(0, n, len_):\n            if s[start:start + len_] != s[start + cnt * len_:start + 2 * cnt * len_]:\n                found = False\n                break", "from collections import defaultdict\n\ndef solve(s):\n    n = len(s)\n    res = 0\n    next_index = defaultdict(lambda: defaultdict(int))\n    dp = [[0]*n for _ in range(n)]\n\n    for i in range(n-1, -1, -1):\n        for j in range(i+1, n):\n            if s[i] == s[j]:\n                if i+1 < j:\n                    dp[i][j] = dp[i+1][j-1", "def solve():\n    N = int(input())\n    S = input()\n\n    max_len = 0\n    for len in range(1, N):\n        seen = set()\n        for i in range(N - len + 1):\n            substr = S[i:i+len]\n            if substr in seen:\n                max_len = max(max_len, len)\n            seen.add(substr)\n    print(max_len)\n\nsolve()\n\n\nThis solution works by iterating over all possible lengths of substrings to check."], "prompt": "\nQUESTION:\nGiven is a string S of length N.\nFind the maximum length of a non-empty string that occurs twice or more in S as contiguous substrings without overlapping.\nMore formally, find the maximum positive integer len such that there exist integers l_1 and l_2 ( 1 \\leq l_1, l_2 \\leq N - len + 1 ) that satisfy the following:\n - l_1 + len \\leq l_2\n - S[l_1+i] = S[l_2+i] (i = 0, 1, ..., len - 1)\nIf there is no such integer len, print 0.\n\n-----Constraints-----\n - 2 \\leq N \\leq 5 \\times 10^3\n - |S| = N\n - S consists of lowercase English letters.\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN\nS\n\n-----Output-----\nPrint the maximum length of a non-empty string that occurs twice or more in S as contiguous substrings without overlapping. If there is no such non-empty string, print 0 instead.\n\n-----Sample Input-----\n5\nababa\n\n-----Sample Output-----\n2\n\nThe strings satisfying the conditions are: a, b, ab, and ba. The maximum length among them is 2, which is the answer.\nNote that aba occurs twice in S as contiguous substrings, but there is no pair of integers l_1 and l_2 mentioned in the statement such that l_1 + len \\leq l_2.\nPlease provide the solution as pure code only, without explanations or comments.\n\nANSWER:\n```python\n"}}