{"3108": {"code": ["def max_average_subsequence(n, k, a):\n    sum_k = sum(a[:k])\n    max_sum = sum_k\n    for i in range(k, n):\n        sum_k += a[i] - a[i-k]\n        max_sum = max(max_sum, sum_k)\n    return max_sum / k\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\nprint(\"{:.6f}\".format(max_average_subsequence(n, k, a)))\n\n\nExplanation:\nThe solution uses a sliding window approach to solve the problem. The window size is `k` and it slides over the array `a` from left to right. For each window, it calculates the sum of the numbers in the window and compares it with the maximum sum found so far. The maximum sum is the answer. The sum is updated by subtracting the first number in the previous window and adding the next number in the array.\n\nThe time complexity of the solution is `O(", "def solve(n, k, a):\n    max_avg = sum(a[:k])\n    cur_sum = max_avg\n    for i in range(k, n):\n        cur_sum += a[i] - a[i-k]\n        max_avg = max(max_avg, cur_sum)\n    return max_avg / k\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\nprint(solve(n, k, a))\n\n\nExplanation:\nThis solution uses a sliding window approach to find the maximum average. The window size is 'k'. The sum of the first 'k' elements is initially calculated and stored in 'max_avg' and 'cur_sum'. Then for the remaining elements, the difference between the current element and the element 'k' positions behind it is subtracted from 'cur_sum' and the new sum is compared with 'max_avg'. If the new sum is greater, it is stored in 'max_avg'. Finally, the maximum average is calculated by div", "def solve():\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    max_avg = sum(a[:k]) / k\n    running_sum = sum(a[:k])\n    for i in range(k, n):\n        running_sum += a[i] - a[i-k]\n        max_avg = max(max_avg, running_sum / k)\n    print(\"{:.6f}\".format(max_avg))\n\nsolve()\n\n\nEXPLANATION:\nThis code uses a sliding window approach to solve the problem. It first calculates the sum of the first `k` elements and sets this as the maximum average `max_avg`. It also keeps track of the running sum of the `k` elements.\n\nThen, for each subsequent element in the array, it subtracts the first element of the previous window and adds the current element, thereby effectively sliding the window one step to the right. It then calculates the new average and updates `max_avg` if the new average", "def max_avg_subsequence(N, K, sequence):\n    max_avg = sum(sequence[:K])\n    running_sum = max_avg\n    for i in range(K, N):\n        running_sum = running_sum - sequence[i-K] + sequence[i]\n        max_avg = max(max_avg, running_sum)\n    return max_avg / K\n\nN, K = map(int, input().split())\nsequence = list(map(int, input().split()))\nprint('{:.6f}'.format(max_avg_subsequence(N, K, sequence)))\n\n\nEXPLANATION:\nThe code first reads in the number of elements and the length of the subsequence to consider, as well as the sequence of integers. It then calculates the sum of the first K elements to initialize the running sum and the maximum average.\n\nThe code then iterates over the sequence from the Kth element onwards, subtracting the Kth element before and adding the current element, which effectively slides the window of the required length along the sequence.", "def max_avg_subsequence(n, k, a):\n    max_avg = 0\n    for i in range(k-1, n):\n        cur_sum = sum(a[i-k+1:i+1])\n        if cur_sum > max_avg:\n            max_avg = cur_len\n    return max_avg / k\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\nprint(max_avg_subsequence(n, k, a))\n\n\nThis solution works by iterating over all possible subsequences of length `k` in the array `a`. For each subsequence, it calculates the sum and updates `max_avg` if the sum is greater than the current `max_avg`. Finally, it returns the `max_avg` divided by `k` as the maximum possible average.\n\nThe time complexity of this solution is O(n*k) and the space complexity is O(1), as it only uses a constant amount of space to store the input and"], "prompt": "\nQUESTION:\nYou are given an array of $N$ integers. Find a consecutive subsequence of numbers of the length at least $K$ that has the maximal possible average.\n\n-----Input-----\nThe first line of input contains two integers $N$ ($1 \\leq N \\leq 3 \\cdot 10^5$) and $K$ ($1 \\leq K \\leq N$). The second line of input contains $N$ integers $a_ i$ ($1 \\leq a_ i \\leq 10^6$).\n\n-----Output-----\nThe first and only line of output must contain the maximal possible average. An absolute deviation of $\\pm 0.001$ from the official solution is permitted.\n\n-----Examples-----\nSample Input 1:\n4 1\n1 2 3 4\nSample Output 1:\n4.000000\n\nSample Input 2:\n4 2\n2 4 3 4\nSample Output 2:\n3.666666\nPlease provide the solution as pure code only, without explanations or comments.\n\nANSWER:\n```python\n"}}