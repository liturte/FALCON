{"3669": {"code": ["def game_winner(N, points):\n    # Sort the points based on the x and y coordinates\n    points.sort(key=lambda x: (x[0], x[1]))\n\n    # Initialize the counters for Mirko and Slavko\n    mirko_counter = 0\n    slavko_counter = 0\n\n    # Loop through the points\n    for i in range(N):\n        # If the point is on the same y-coordinate as the previous point,\n        # Mirko can draw a line parallel to the x-axis and win\n        if i > 0 and points[i][1] == points[i-1][1]:\n            mirko_counter += 1\n        # If the point is on the same x-coordinate", "def find_winner(points):\n    sorted_points = sorted(points)\n    if len(set(x for x, y in sorted_points)) == len(sorted_points):\n        return \"Slavko\"\n    else:\n        return \"Mirko\"\n\nN = int(input())\npoints = [tuple(map(int, input().split())) for _ in range(N)]\nprint(find_winner(points))\n\n\nThis solution works by sorting the points by their x-coordinates. If the y-coordinates of all the points are different, Mirko can always play and win. If not, Slavko can always play and win. The function `find_winner` returns the appropriate winner based on this logic.", "def game():\n    N = int(input())\n    points = [tuple(map(int, input().split())) for _ in range(N)]\n    points.sort(key=lambda x: (x[0], x[1]))\n    mirko_moves = []\n    slavko_moves = []\n    for i in range(N):\n        if i % 2 == 0:\n            mirko_moves.append(points[i])\n        else:\n            slavko_moves.append(points[i])\n    mirko_wins = True\n    for i in range(1, len(mirko_moves)):\n        if mirko_moves[i][0] < mirko_moves[i-", "def check_horizontal_line(points):\n    x_coords = [x for x, y in points]\n    return len(set(x_coords)) == 1\n\ndef check_vertical_line(points):\n    y_coords = [y for x, y in points]\n    return len(set(y_coords)) == 1\n\ndef who_wins(N, points):\n    horizontal_wins = check_horizontal_line(points)\n    vertical_wins = check_vertical_line(points)\n\n    if horizontal_wins and vertical_wins:\n        return \"Mirko\"\n    elif horizontal_wins:\n        return \"Mirko\"\n    elif vertical_wins:\n        return \"Slav", "def find_winner(points):\n    points.sort()\n    mirko_turn = True\n    for i in range(len(points) - 1):\n        if points[i][0] == points[i + 1][0] and mirko_turn:\n            mirko_turn = False\n        elif points[i][1] == points[i + 1][1] and not mirko_turn:\n            mirko_turn = True\n        else:\n            return \"Mirko\" if mirko_turn else \"Slavko\"\n    return \"Mirko\" if mirko_turn else \"Slavko\"\n\nN = int(input().strip())\npoints = [list(map(int, input().strip().split())) for _ in range"], "prompt": "\nQUESTION:\nMirko and his faithful friend Slavko got really bored one day. The result of their boredom is the creation of a new game! In the beginning of the game, they draw $N$ points in a coordinate system. The players take turns and Mirko plays first. He draws a straight line which is parallel to one of the axes of the coordinate system and passes through one of the $N$ points. In the following moves, the player draws a straight line which is parallel to one of the axes of the coordinate system and passes through one of the $N$ points located on the line drawn in the previous move of the opponent. No single line must be drawn twice. The loser is the player who cannot play his move. Determine who has the winning strategy.\n\n-----Input-----\nThe first and only line of input contains the positive integer $N$ ($1 \\leq N \\leq 10000$). Each of the following $N$ lines contains two integers $X$ and $Y$, the coordinates of the points drawn ($1 \\leq X,Y \\leq 500$).\n\n-----Output-----\nThe first and only line of output must contain the name of the winner, either \u201cMirko\u201d or \u201cSlavko\u201d.\n\n-----Examples-----\nSample Input:\n3\n1 1\n1 2\n1 3\nSample Output:\nMirko\nPlease provide the solution as pure code only, without explanations or comments.\n\nANSWER:\n```python\n"}}