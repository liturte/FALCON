{"737": {"code": ["import math\n\ndef shortest_perimeter(n):\n    factors = []\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            factors.append((i, n // i))\n    min_perimeter = float('inf')\n    for factor in factors:\n        min_perimeter = min(min_perimeter, 2 * (factor[0] + factor[1]))\n    return min_perimeter\n\nprint(shortest_perimeter(int(input().strip())))\n\nIn this solution, we first generate all factors of the input number. Then, for each factor pair, we calculate the perimeter of the rectangle that can be formed with these factors (2*(width + length)) and keep track of the minimum perimeter.\n\nWe only need to check factors up to the square root of the number, because a larger factor would have already been covered by a smaller one.\n\nThis solution runs in O(sqrt(n)) time complexity, which is efficient enough for the maximum input size of", "import math\n\ndef min_perimeter(N):\n    min_peri = float('inf')\n    i = 1\n    while i <= math.isqrt(N):\n        if N % i == 0:\n            j = N // i\n            min_peri = min(min_peri, 2*(i+j))\n        i += 1\n    return min_peri\n\nprint(min_perimeter(int(input())))\n\n\nExplanation:\nThis Python code uses the concept of prime factorization to find the minimum perimeter. It starts from 1 and goes up to the square root of the given number, checking each number to see if it is a factor. If it is, it calculates the perimeter of the rectangle (2*(i+j)) and updates the minimum perimeter if the calculated perimeter is smaller.\n\nIt then returns the minimum perimeter.\n\nThis code will run in O(sqrt(N)) time complexity, which is efficient for the given constraints of N <= 10^6.\n\nThe reason for using square root as the upper", "import math\n\ndef min_perimeter(N):\n    min_perimeter = float('inf')\n    for i in range(1, int(math.sqrt(N)) + 1):\n        if N % i == 0:\n            min_perimeter = min(min_perimeter, 2 * (i + N // i))\n    return min_perimeter\n\nN = int(input())\nprint(min_perimeter(N))\n\nThis code works by iterating over the possible factors of N and for each factor, it computes the perimeter of the rectangle with that factor as the width and N // factor as the height. It then updates the minimum perimeter found so far.\n\nIt uses the fact that the perimeter of a rectangle is 2 * (width + height), and that the area of a rectangle is width * height. Therefore, to minimize the perimeter, we want to maximize the area, which is achieved when width and height are as close together as possible.\n\nThe time complexity of this code is O(sqrt(N)) because it iterates over the factors", "import math\n\ndef min_perimeter(N):\n    min_peri = float('inf')\n    for i in range(1, int(math.sqrt(N))+1):\n        if N % i == 0:\n            min_peri = min(min_peri, 2*(i + N//i))\n    return min_peri\n\nprint(min_perimeter(int(input().strip())))\n\n\nEXPLANATION:\nThe solution works by iterating over possible factors of N and finding the minimum perimeter for each. The perimeter of a rectangle is 2*(length + width). In this case, the length and width are the factors of N. The solution uses the property that the factors of N are symmetric about the square root of N. Therefore, it only needs to iterate up to the square root of N.\n\nThe time complexity of this solution is O(sqrt(N)) because in the worst case it needs to iterate over all possible factors of N.\n\nThe space complexity is O(1) because it only needs a constant amount of space to store", "def min_perimeter(n):\n    min_perimeter = float('inf')\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            min_perimeter = min(min_perimeter, 2 * (i + n // i))\n        i += 1\n    return min_perimeter\n\nn = int(input().strip())\nprint(min_perimeter(n))\n\n\nExplanation:\nThe function `min_perimeter` calculates the minimum perimeter for a given number of city blocks `n`. It starts by initializing the minimum perimeter to infinity. Then, it iterates from 1 to the square root of `n`, checking if `n` is divisible by `i`. If it is, it calculates the perimeter for this shape (2 * (i + n // i)) and updates the minimum perimeter if necessary. Finally, it returns the minimum perimeter.\n\nIn the main part of the code, it reads an integer from the input, calls `min_perimeter`"], "prompt": "\nQUESTION:\nYour security guard friend recently got a new job at a new security company. The company requires him to patrol an area of the city encompassing exactly N city blocks, but they let him choose which blocks. That is, your friend must walk the perimeter of a region whose area is exactly N blocks. Your friend is quite lazy and would like your help to find the shortest possible route that meets the requirements. The city is laid out in a square grid pattern, and is large enough that for the sake of the problem it can be considered infinite.\n\n\n-----Input-----\n\nInput will consist of a single integer N (1 \u2264 N \u2264 10^6), the number of city blocks that must be enclosed by the route.\n\n\n-----Output-----\n\nPrint the minimum perimeter that can be achieved.\n\n\n-----Examples-----\nInput\n4\n\nOutput\n8\n\nInput\n11\n\nOutput\n14\n\nInput\n22\n\nOutput\n20\n\n\n\n-----Note-----\n\nHere are some possible shapes for the examples:\n\n[Image]\nPlease provide the solution as pure code only, without explanations or comments.\n\nANSWER:\n```python\n"}}