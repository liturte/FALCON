{"3873": {"code": ["def solve(n):\n    if n == 1:\n        return [(1, 1)]\n    else:\n        return [(i, i+1) for i in range(1, n)] + [(1, 2)]\n\nn = int(input())\nif n == 1:\n    print(\"YES\")\n    print(1)\nelse:\n    print(\"YES\")\n    print(\"\\n\".join(\" \".join(str(i) for i in x) for x in solve(n)))\n\n\nThis code first checks if the size of the permutation is 1. If", "def swap_positions(n):\n    if n == 1:\n        return [(1, 1)]\n    else:\n        return [(i, i+1) for i in range(1, n) if i % 2 == 0] + [(1, 2)] + [(i, i+1) for i in range(2, n+1) if i % 2 != 0]\n\nn = int(input())\nif n == 1 or n % 2 == 0:\n    print(\"YES\")\n    for pair in swap_positions(n):\n        print(pair[", "def swap_positions(n):\n    if n == 1:\n        return [(1, 1)]\n    else:\n        return [(i, i + 1) for i in range(1, n)] + [(1, 1)]\n\nn = int(input().strip())\nif n == 1:\n    print(\"YES\")\n    print(1)\nelse:\n    print(\"YES\")\n    for pair in swap_positions(n):\n        print(pair[0], pair[1])\n\n\nExplanation:\nFor n = 1, the only permutation is the", "def solve(n):\n    if n == 1:\n        return [(1, 1)]\n    else:\n        return [(i, i+1) for i in range(1, n)] + [(1, 2)] * (n // 2)\n\nn = int(input())\nif n == 1 or n % 2 == 0:\n    print(\"YES\")\n    for swap in solve(n):\n        print(*swap)\nelse:\n\n    print(\"NO\")\n\n\nThis Python program works by first checking if the number of elements in the permutation is 1 or", "def swap_pairs(n):\n    if n == 1:\n        return [(1, 1)]\n    else:\n        return [(i, i+1) for i in range(1, n, 2)] + [(1, 2)] + [(i, i+1) for i in range(2, n-1, 2)]\n\nn = int(input())\n\nif n % 2 == 0:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    for pair in swap_pairs(n):\n        print(pair[0], pair"], "prompt": "\nQUESTION:\nSeyyed and MoJaK are friends of Sajjad. Sajjad likes a permutation. Seyyed wants to change the permutation in a way that Sajjad won't like it. Seyyed thinks more swaps yield more probability to do that, so he makes MoJaK to perform a swap between every pair of positions (i, j), where i < j, exactly once. MoJaK doesn't like to upset Sajjad.\n\nGiven the permutation, determine whether it is possible to swap all pairs of positions so that the permutation stays the same. If it is possible find how to do that. \n\n\n-----Input-----\n\nThe first line contains single integer n (1 \u2264 n \u2264 1000)\u00a0\u2014 the size of the permutation.\n\nAs the permutation is not important, you can consider a_{i} = i, where the permutation is a_1, a_2, ..., a_{n}.\n\n\n-----Output-----\n\nIf it is not possible to swap all pairs of positions so that the permutation stays the same, print \"NO\",\n\nOtherwise print \"YES\", then print $\\frac{n(n - 1)}{2}$ lines: the i-th of these lines should contain two integers a and b (a < b)\u00a0\u2014 the positions where the i-th swap is performed.\n\n\n-----Examples-----\nInput\n3\n\nOutput\nNO\n\nInput\n1\n\nOutput\nYES\nPlease provide the solution as pure code only, without explanations or comments.\n\nANSWER:\n```python\n"}}