{"1812": {"code": ["import sys\n\ndef solve():\n    n = int(sys.stdin.readline())\n    for _ in range(n):\n        a = int(sys.stdin.readline())\n        print(find_k(a))\n\ndef find_k(a):\n    binary = bin(a)[2:]\n    length = len(binary)\n    k = 0\n    while True:\n        k += 1\n        power_of_two =", "from math import ceil, log2\n\ndef binary_search(n, l, r):\n    while l < r:\n        mid = (l + r) // 2\n        if pow(2, mid, n) == 2:\n            return mid\n        elif pow(2, mid, n) < 2:\n            l = mid + 1\n        else:\n            r = mid\n    return l\n\ndef solve(a):\n    return binary_", "from math import log2, ceil\n\ndef solve(a):\n    res = []\n    for a in A:\n        k = ceil(log2(a)) + 1\n        res.append(k)\n    return res\n\nn = int(input())\nA = [int(input()) for _ in range(n)]\nprint(\"\\n\".join(map(str, solve(A))))\n\n\nExplanation:\nThis code sol", "def find_k(n, a):\n    result = []\n    for i in range(n):\n        binary = bin(a[i])[2:]\n        length = len(binary)\n        k = 1\n        while True:\n            power_of_2 = bin(2**k)[2:]\n            if power_of_2.endswith(binary):\n                result.append(k)\n                break\n            elif len(power_of", "def solve(n, a):\n    def check(x, y):\n        x = str(x)\n        y = str(y)\n        return y in x[-len(y):]\n\n    def binary_search(a, l, r, k):\n        if r - l <= 1:\n            return l\n        m = (l + r) // 2\n        if check(2 ** m, a):\n            return binary_search(a"], "prompt": "\nQUESTION:\nYou are given n positive integers a_1, a_2, ..., a_{n}.\n\nFor every a_{i} you need to find a positive integer k_{i} such that the decimal notation of 2^{k}_{i} contains the decimal notation of a_{i} as a substring among its last min(100, length(2^{k}_{i})) digits. Here length(m) is the length of the decimal notation of m.\n\nNote that you don't have to minimize k_{i}. The decimal notations in this problem do not contain leading zeros.\n\n\n-----Input-----\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 000)\u00a0\u2014 the number of integers a_{i}.\n\nEach of the next n lines contains a positive integer a_{i} (1 \u2264 a_{i} < 10^11).\n\n\n-----Output-----\n\nPrint n lines. The i-th of them should contain a positive integer k_{i} such that the last min(100, length(2^{k}_{i})) digits of 2^{k}_{i} contain the decimal notation of a_{i} as a substring. Integers k_{i} must satisfy 1 \u2264 k_{i} \u2264 10^50.\n\nIt can be shown that the answer always exists under the given constraints. If there are multiple answers, print any of them.\n\n\n-----Examples-----\nInput\n2\n8\n2\n\nOutput\n3\n1\n\nInput\n2\n3\n4857\n\nOutput\n5\n20\nPlease provide the solution as pure code only, without explanations or comments.\n\nANSWER:\n```python\n"}}