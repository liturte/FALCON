{"2881": {"code": ["def match_sticks():\n    X, Y = input().split()\n    for i in range(len(X)):\n        if X[i] != Y[i]:\n            if X[i+1:] == Y[i+1:]:\n                return \"yes\"\n            else:\n                return \"no\"\n\nprint(match_sticks())\n\n\nEXPLANATION:\nThe solution is a simple loop that iterates over the digits in the two sequences X and Y. If the digits are not equal at a certain position in the sequences, it checks if the rest of the sequence X after the current position is equal to the rest of the sequence Y after the current position. If it is, it means we can move a match from the digit in sequence X to make it equal to the digit in sequence Y, so it returns \"yes\". If the rest of the sequences are not equal, it returns \"no\".\n\nPlease note that this solution assumes that the input will always be valid", "x, y = input().split()\nprint(\"yes\" if sum(i != j for i, j in zip(x, y)) == 1 else \"no\")\n\n\nExplanation:\nThe solution takes two inputs $X$ and $Y$. Then it checks if the difference in the number of matches between the two sequences is exactly one. If it is, it prints \"yes\", otherwise it prints \"no\". The `zip` function is used to iterate over two sequences simultaneously. The `sum` function is used to count the number of differences.\n\nThis solution assumes that the \"move exactly one match\" means that one match in one sequence must be different from the corresponding match in the other sequence. If the \"move exactly one match\" means that one match must be removed from one sequence and added to the other sequence, the solution would need to be adjusted accordingly.\n\nThe solution also assumes that the sequences are not allowed to have leading zeros. If leading zeros are allowed, the solution would need to be adjusted", "X, Y = input().split()\ndiff = [i for i in range(10) if X[i] != Y[i]]\nif len(diff) == 2 and X[diff[0]] == Y[diff[1]] and X[diff[1]] == Y[diff[0]]:\n    print('yes')\nelse:\n    print('no')\n\nThis program works by first getting the two sequences X and Y from the user. It then creates a list of the indices where the characters in X and Y differ. If there are exactly two such indices, it checks if the character at the index in X is the character that would be at the index in Y if a match was moved from X, and vice versa. If both of these conditions are met, it prints 'yes'. Otherwise, it prints 'no'.\n\nThis program assumes that the input is always valid and does not include error checking for invalid inputs.", "def match_sticks():\n    X, Y = input().split()\n    for i in range(len(X)):\n        if X[i] != Y[i]:\n            if X[i+1:] == Y[i+1:]:\n                return 'yes'\n    return 'no'\n\nprint(match_sticks())\n\n\nThis code works by iterating over each character in the input strings. If it finds a mismatch, it checks if the rest of the string matches in the other direction. If it does, it returns 'yes'. If it doesn't find any mismatches or matches in the other direction, it returns 'no'.\n\nPlease note that the code assumes that the input strings are always of the same length and that there is at least one mismatch. If this is not the case, you would need to add error checking to handle these conditions.", "X, Y = input().split()\ncount_X = [0]*10\ncount_Y = [0]*10\nfor i in X:\n    count_X[int(i)] += 1\nfor i in Y:\n    count_Y[int(i)] += 1\ndiff = [(i-j)%10 for i, j in zip(count_X, count_Y)]\nprint('yes' if diff.count(1) == 1 and diff.count(9) == 1 else 'no')\n\n\nExplanation:\nThe code counts the number of occurrences of each digit in the sequences X and Y. It then calculates the difference between the counts of the digits in X and Y (modulo 10 to handle the wraparound from 9 to 0). If there is exactly one difference of 1 and one difference of 9, then it means that one match can be moved from X to make it equal to Y. Otherwise, it"], "prompt": "\nQUESTION:\nMatch sticks can be used to form digital numbers. The arrangement of matches that forms each digit between \u20180\u2019 and \u20189\u2019 is illustrated in the figure.\n\nYou are given two sequences of digits $X$ and $Y$. There are matches that have been arranged to form the digits in $X$. Can you move exactly one match from them, so that the resulting matches form the other sequence $Y$?\n\n-----Input-----\nThe input contains one line with two sequences of digits $X$ and $Y$. It is guaranteed that $X$ and $Y$ have the same length but are different sequences. Each sequence contains digits between \u20180\u2019 and \u20189\u2019 and has at least one and no more than $12$ digits. A sequence may contain leading zeros.\n\n-----Output-----\nOutput \u201cyes\u201d if it is possible to move exactly one match to change $X$ into $Y$. Otherwise output \u201cno\u201d.\n\n-----Examples-----\nSample Input 1:\n60 58\nSample Output 1:\nyes\n\nSample Input 2:\n046 040\nSample Output 2:\nyes\nPlease provide the solution as pure code only, without explanations or comments.\n\nANSWER:\n```python\n"}}