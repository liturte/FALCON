{"3462": {"code": ["import sys\nimport re\n\ndef list_files(pattern, files):\n    pattern = pattern.replace('.', '\\.').replace('*', '.*')\n    pattern = re.compile(pattern)\n    for file in files:\n        if pattern.match(file):\n            print(file)\n\nif __name__ == \"__main__\":\n    pattern = sys.stdin.readline().strip()\n    num_files = int(sys.stdin.readline().strip())\n    files = [sys.stdin.readline().strip() for _ in range(num_files)]\n    list_files(pattern, files)\n\n\nThis Python solution uses the built-in `re` module to compile the pattern and match it against each file. The `re.compile` function is used to convert the pattern string into a regular expression object, which can be used to match against strings.", "import sys\nimport fnmatch\n\ndef main():\n    pattern = sys.stdin.readline().strip()\n    num_files = int(sys.stdin.readline())\n    files = [sys.stdin.readline().strip() for _ in range(num_files)]\n\n    for file in files:\n        if fnmatch.fnmatch(file, pattern):\n            print(file)\n\nif __name__ == \"__main__\":\n    main()\n\n\nThis solution uses Python's built-in `fnmatch` module, which provides a non-blocking match() function. This function takes two arguments: the file name to match and the pattern to match against. If the file name matches the pattern, it returns `True`; otherwise, it returns `False`.\n\nIn the main function, we first read the pattern and the number of files from the input. We then", "import re\n\ndef match_pattern(filename, pattern):\n    # convert pattern to regex\n    pattern = pattern.replace('.', '\\.')\n    pattern = pattern.replace('*', '.*')\n    return bool(re.match(pattern, filename))\n\ndef solve():\n    pattern = input()\n    n = int(input())\n    files = [input() for _ in range(n)]\n    for file in files:\n        if match_pattern(file, pattern):\n            print(file)\n\nsolve()\n\n\nThis Python program firstly reads the pattern and the number of files from the input. Then, it reads the names of the files from the input. For each file, it checks if the file name matches the pattern. If it does, it prints the file name.\n\nThe function `match_pattern` takes a filename and a pattern as input and returns `True` if", "import sys\nimport fnmatch\n\ndef main():\n    pattern = sys.stdin.readline().strip()\n    num_files = int(sys.stdin.readline().strip())\n    for i in range(num_files):\n        filename = sys.stdin.readline().strip()\n        if fnmatch.fnmatch(filename, pattern):\n            print(filename)\n\nif __name__ == \"__main__\":\n    main()\n\n\nThis solution uses the `fnmatch` module, which provides a non-blocking way to match Unix shell style patterns. It's a simple and efficient way to list files matching a pattern.\n\nThe `main` function reads the pattern and the number of files from the input. Then it reads each filename and checks if it matches the pattern using the `fnmatch.fnmatch` function. If it does, it prints the filename.", "import sys\nimport re\n\ndef list_files(pattern, files):\n    pattern = pattern.replace('.', '\\.').replace('*', '.*')\n    prog = re.compile(pattern)\n    for file in files:\n        if prog.match(file):\n            print(file)\n\ndef main():\n    pattern = sys.stdin.readline().strip()\n    num_files = int(sys.stdin.readline().strip())\n    files = [sys.stdin.readline().strip() for _ in range(num_files)]\n    list_files(pattern, files)\n\nif __name__ == \"__main__\":\n    main()\n\n\nThis code reads the pattern and the number of files from the standard input, then reads the filenames into a list. It then calls the `list_files` function with the pattern and the list"], "prompt": "\nQUESTION:\nYou are implementing an operating system, and now need to write a program to list files in a directory: \u201cls\u201d. You want the user to be able to list only files that match a given pattern that can include wildcards (*), for example *.c. A wildcard matches zero or more characters of any kind.\n\n-----Input-----\nThe first line contains a string $P$, containing $1$\u2013$100$ characters \u2019a\u2019\u2013\u2019z\u2019, \u2019*\u2019 and \u2019.\u2019. This is the pattern. The second line contains an integer $N$, $1 \\leq N \\leq 100$, which is the number of files in the directory. Then follow $N$ lines containing the names of the files in the directory. Each line is a string containing $1$\u2013$100$ characters \u2019a\u2019\u2013\u2019z\u2019 and \u2019.\u2019.\n\n-----Output-----\nThe output shall consist of the filenames that match the pattern, $P$, each on its own line, in the same order that they were given as input.\n\n-----Examples-----\nSample Input:\n*.*\n4\nmain.c\na.out\nreadme\nyacc\nSample Output:\nmain.c\na.out\nPlease provide the solution as pure code only, without explanations or comments.\n\nANSWER:\n```python\n"}}