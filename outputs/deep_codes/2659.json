{"2659": {"code": ["from heapq import heappop, heappush\n\ndef snuke(k):\n    h = [(1, 1)]\n    snuke_numbers = []\n    while len(snuke_numbers) < k:\n        n, s = heappop(h)\n        snuke_numbers.append(n)\n        for i in range(n % 10 + 1, 10):\n            next_n = n * 10 + i\n            next_s = s + i\n            if next_n * 10 // next_s > n:\n                heappush(h, (next_n, next_s))\n    return snuke_numbers\n\nprint('\\n'.join(map(str, snuke(int(input())))))\n\n\nThis Python code uses a heap to keep track of the smallest Snuke numbers. The heap is initialized with the number 1. Then, for each number in the heap, we generate all possible next numbers by appending a digit to the end of the current number. We only consider the next numbers that have a smaller denominator than the current number", "from heapq import *\n\ndef snuke(K):\n    def S(n):\n        return sum(map(int, str(n)))\n\n    def generator():\n        n = 1\n        while True:\n            yield n\n            n += 1\n\n    pq, gen = [], generator()\n    heappush(pq, (next(gen) / S(1), 1))\n    for _ in range(K):\n        n, s = heappop(pq)\n        yield n\n        heappush(pq, (next(gen) / S(s+1), s+1))\n\nprint('\\n'.join(map(str, next(snuke(K)) for _ in range(K))))\n\n\nThis Python program uses a priority queue to keep track of the smallest Snuke numbers. The priority queue is implemented using the heapq module. The generator function generator() generates the positive integers in ascending order, starting from 1. The S(n) function calculates the sum of the digits in the decimal notation of n. The main function snuke(K) generates the first K Snuke numbers", "from heapq import *\n\ndef S(n):\n    return sum(map(int, str(n)))\n\ndef Snuke_numbers(K):\n    q = [(n, S(n)) for n in range(1, 10)]\n    heapify(q)\n    result = []\n    while len(result) < K:\n        n, s = heappop(q)\n        result.append(n)\n        for m in range(n+1, min(n+10, 10**16)):\n            sm = S(m)\n            if n*sm < m*s:\n                break\n            heappush(q, (m, sm))\n    return result\n\nprint('\\n'.join(map(str, Snuke_numbers(int(input())))))\n\n\nExplanation:\n\nThis solution uses a heap to keep track of the smallest Snuke numbers. The heap is initialized with the first 9 Snuke numbers (1-9). Then, it pops the smallest number from the heap, adds it to the result, and pushes new numbers into the heap", "from heapq import *\n\ndef snuke_numbers(k):\n    def S(n): return sum(map(int, str(n)))\n    pq, res, visited = [(1, 1)], [], set()\n    for _ in range(k):\n        d, n = heappop(pq)\n        res.append(n)\n        for i in range(n%10+1, 10):\n            next_n = n*10+i\n            next_d = next_n//S(next_n)\n            if (next_n, next_d) not in visited:\n                visited.add((next_n, next_d))\n                heappush(pq, (next_d, next_n))\n    return res\n\nprint(*snuke_numbers(int(input())), sep='\\n')\n\n\nThis python code uses a priority queue to find the smallest Snuke numbers. It starts with 1 and generates all possible numbers that can be formed by appending digits to 1. It ensures that the generated numbers are in ascending order by maintaining a priority", "import heapq\n\ndef S(n):\n    return sum(map(int, str(n)))\n\ndef Snuke(K):\n    hq = [(1, 1)]\n    seen = set()\n    for _ in range(K):\n        n, m = heapq.heappop(hq)\n        yield n\n        for d in range(0, 10):\n            next_n = n * 10 + d\n            next_m = m * 10 + 9\n            if (next_n, next_m) not in seen:\n                seen.add((next_n, next_m))\n                heapq.heappush(hq, (next_n, next_m))\n\nprint('\\n'.join(map(str, next(Snuke(K)) for _ in range(K))))\n\n\nThis solution uses a priority queue (heap) to track the next smallest Snuke number. The heap is initialized with the number 1. The next Snuke number is then calculated by taking the smallest number from the heap, appending a digit from 0 to 9, and"], "prompt": "\nQUESTION:\nLet S(n) denote the sum of the digits in the decimal notation of n.\nFor example, S(123) = 1 + 2 + 3 = 6.\nWe will call an integer n a Snuke number when, for all positive integers m such that m > n, \\frac{n}{S(n)} \\leq \\frac{m}{S(m)} holds.\nGiven an integer K, list the K smallest Snuke numbers.\n\n-----Constraints-----\n - 1 \\leq K\n - The K-th smallest Snuke number is not greater than 10^{15}.\n\n-----Input-----\nInput is given from Standard Input in the following format:\nK\n\n-----Output-----\nPrint K lines. The i-th line should contain the i-th smallest Snuke number.\n\n-----Sample Input-----\n10\n\n-----Sample Output-----\n1\n2\n3\n4\n5\n6\n7\n8\n9\n19\n\nPlease provide the solution as pure code only, without explanations or comments.\n\nANSWER:\n```python\n"}}