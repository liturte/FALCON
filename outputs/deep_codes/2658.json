{"2658": {"code": ["def find_town(N, K, A):\n    visited = [0] * (N+1)\n    teleport = [0] * (N+1)\n    for i in range(1, N+1):\n        if visited[i] == 0:\n            current = i\n            cycle = []\n            while True:\n                visited[current] = 1\n                cycle.append(current)\n                current = A[current]\n                if visited[current] == 1:\n                    break\n            start = cycle.index(current)\n            end = len(cycle) - 1\n            teleport[i] = [start, end]\n        else:\n            continue\n    if K <= teleport[1][1]:\n        return cycle[K]\n    else:", "N, K = map(int, input().split())\nA = list(map(int, input().split()))\n\n# Initialize the visited and teleport arrays\nvisited = [0] * (N + 1)\nteleport = [0] * (N + 1)\n\n# Loop through the teleport array and mark the teleport destinations\nfor i in range(1, N + 1):\n    teleport[i] = A[i - 1]\n\n# Loop through the teleport array and find the loop if it exists\n# If it does, break the loop and calculate the remaining teleports\nfor i in range(1, N + 1):\n    if visited[i] == 0:\n        start = i\n        while True:\n            visited[start] = 1", "N, K = map(int, input().split())\nA = list(map(int, input().split()))\n\ndef solve(N, K, A):\n    visited = [0] * N\n    current = 0\n    visited[0] = 1\n    for _ in range(K):\n        current = A[current] - 1\n        if visited[current]:\n            break\n        visited[current] = 1\n    else:\n        return current + 1\n\n    cycle_start = current\n    cycle_length = 0\n    while True:\n        current = A[current] - 1\n        cycle_length += 1\n        if current == cycle_start:\n            break\n\n    K %= cycle_length\n    for _ in range(K):\n        current = A", "def find_town(n, k, a):\n    visited = [0] * (n + 1)\n    town = 1\n    for _ in range(k):\n        visited[town] = 1\n        town = a[town - 1]\n        if visited[town]:\n            break\n    else:\n        return town\n    cycle_start = town\n    cycle_length = 1\n    town = a[town - 1]\n    while town != cycle_start:\n        cycle_length += 1\n        town = a[town - 1]\n    k %= cycle_length\n    for _ in range(k):\n        town = a[town - 1]\n    return town\n\nn, k = map(int, input().split())\na = list(", "from collections import deque\n\nN, K = map(int, input().split())\nA = list(map(int, input().split()))\n\nvisited = [0] * (N + 1)\n\nq = deque([1])\nvisited[1] = 1\nwhile q:\n    town = q.popleft()\n    if visited[town] == K:\n        print(A[town - 1])\n        exit()\n    next_town = A[town - 1]\n    if visited[next_town] == 0:\n        visited[next_town] = visited[town] + 1\n        q.append(next_town)\n    else:\n        if (K - visited[town]) % 2 == 0:\n            print(A[town"], "prompt": "\nQUESTION:\nThe Kingdom of Takahashi has N towns, numbered 1 through N.\nThere is one teleporter in each town. The teleporter in Town i (1 \\leq i \\leq N) sends you to Town A_i.\nTakahashi, the king, loves the positive integer K. The selfish king wonders what town he will be in if he starts at Town 1 and uses a teleporter exactly K times from there.\nHelp the king by writing a program that answers this question.\n\n-----Constraints-----\n - 2 \\leq N \\leq 2 \\times 10^5\n - 1 \\leq A_i \\leq N\n - 1 \\leq K \\leq 10^{18}\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN K\nA_1 A_2 \\dots A_N\n\n-----Output-----\nPrint the integer representing the town the king will be in if he starts at Town 1 and uses a teleporter exactly K times from there.\n\n-----Sample Input-----\n4 5\n3 2 4 1\n\n-----Sample Output-----\n4\n\nIf we start at Town 1 and use the teleporter 5 times, our travel will be as follows: 1 \\to 3 \\to 4 \\to 1 \\to 3 \\to 4.\nPlease provide the solution as pure code only, without explanations or comments.\n\nANSWER:\n```python\n"}}