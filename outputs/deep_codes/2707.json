{"2707": {"code": ["MOD = 10**9 + 7\nn, k = map(int, input().split())\nA = list(map(int, input().split()))\n\ndp = [0]*(k", "MOD = 10**9+7\nn, k = map(int, input().split())\na = list(map(int, input().split()))\ndp = [0]*(k+", "MOD = 10**9 + 7\n\ndef solve(n, k, A):\n    dp = [[0]*(k+2) for _ in range(n+1)]", "MOD = 10**9 + 7\n\ndef solve(n, k, A):\n    dp = [0] * (k + 2)\n    dp[0] = 1", "from collections import Counter\n\nMOD = 10**9+7\n\ndef mex(arr):\n    cnt = Counter(arr)\n    mex = 0\n    while me"], "prompt": "\nQUESTION:\nGiven an array A of n non-negative integers. Find the number of ways to partition/divide the array into subarrays, such that  mex in each subarray is not more than k. For example, mex of the arrays [1, 2] will be 0, and that of [0, 2] will be 1, and that of [0, 1, 2] will be 3. Due to the fact that the answer can turn out to be quite large, calculate it modulo 109\u2009+\u20097.\n\n-----Input-----\n- The first line of the input contains two integers n, k denoting the number of elements and limit of mex.\n- The second line contains n space-separated integers A1, A2, ... , An .\n\n-----Output-----\n- Output a single integer corresponding to the answer of the problem.\n\n-----Constraints-----\n- 1 \u2264 n \u2264 5 * 105\n- 0 \u2264 k, A[i] \u2264 109\n\n-----Example-----\nInput:\n3 1\n0 1 2\n\nOutput:\n2\n\nInput:\n10 3\n0 1 2 3 4 0 1 2 5 3\n\nOutput:\n379\n\n-----Explanation-----\nExample 1. The valid ways of partitioning will be [[0], [1, 2]] (mex of first subarray is 1, while that of the second is zero), and [[0], [1], [2]] (mex of first subarray is 1, and that of others is 0). There is no other way to partition the array such that mex is less than or equal to 1. For example, [[0, 1], [2]] is not a valid partitioning as mex of first subarray is 2 which is more than 1.\nPlease provide the solution as pure code only, without explanations or comments.\n\nANSWER:\n```python\n"}}