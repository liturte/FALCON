{"302": {"code": ["def min_ones(n):\n    if n == 0:\n        return 0\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        dp[i] = min(dp[i - 1] + 1, dp[i - 1] + dp[i // 2] + 1 if i % 2 == 0 else float('inf'))\n    return dp[n]\n\nprint(min_ones(int(input())))\n\n\nThis Python program uses dynamic programming to solve the problem. It creates a list `dp` where `dp[i]` is the minimum number of ones in the representation of `i`. For each `i`, it calculates `dp[i]` as the minimum of `dp[i-1] + 1` (which represents `i` as `i-1` plus one one) and `dp[i-1] + dp[i//2] + 1` (which represents `i` as `i-1` plus the representation of `i//2` plus one one). If `i` is odd, it doesn't add one one because it can't represent `i` as `i//2` plus one one.\n\nFinally, it prints `dp[n]`, which is the minimum number of ones in the representation of `n`.\n\nNote: This solution assumes that the input is a positive integer and does not handle", "def min_ones(n):\n    if n == 1:\n        return 1\n    else:\n        return min(n % 10 + 10 * min_ones(n // 10), (n // 10 + 1) * 10 - n % 10)\n\nn = int(input())\nprint(min_ones(n))\n\n\nThis program uses a recursive function `min_ones` to calculate the minimal number of digits 1 in the sum. It divides the number into two parts: the last digit and the rest of the number. If the last digit is 0, it adds 10 to the result of the recursive call for the rest of the number. If the last digit is not 0, it adds the last digit to the result of the recursive call for the rest of the number and subtracts the last digit from the next higher number. The result is the minimal number of digits 1 in the sum.\n\nThe main part of the program reads the number from the input and prints the result of the `min_ones` function.", "def min_ones(n):\n    if n == 0:\n        return 0\n    else:\n        return n % 9 + 10 * min_ones(n // 9)\n\nn = int(input())\nprint(min_ones(n))\n\n\nEXPLANATION:\nThe problem can be solved by recursively breaking down the number into 9s. Because 9 is the largest number that can be represented by only 1s, we can use it to simplify the problem. If the number is divisible by 9, we can replace it with 9 and reduce the problem to a smaller one. If it's not divisible by 9, we can add enough 1s to make it divisible by 9 and then reduce the problem to a smaller one. The base case is when the number is 0, in which case we return 0. The function returns the number of 1s in the simplified number plus 10 times the number of 1s in the smaller problem.\n\nThis solution has a time complexity of O(log n) because it reduces the problem size at each step.", "def min_ones(n):\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    dp = [0] * (n+1)\n    dp[0] = dp[1] = 1\n    for i in range(2, n+1):\n        dp[i] = min(dp[i-1] + 1, dp[i-2] + 2)\n    return dp[n]\n\nn = int(input())\nprint(min_ones(n))\n\n\nExplanation:\nThe program uses dynamic programming to solve the problem. It builds an array dp where dp[i] is the least number of digits 1 in the sum of positive integers up to i. The base cases are dp[0] = dp[1] = 1 because the least number of digits 1 in 1 and 2 is 1. For i > 1, dp[i] is either dp[i-1] + 1 (if we add a 1 to the sum of positive integers up to i-1) or dp[i-2] + 2 (if we add 2 to the sum of positive integers up to i-2). The answer is dp[n].\n\nThis solution runs in O(n) time and uses O(n) space, which is efficient for large inputs.\n\nNote: The input is assumed to be a positive integer less than 10^15. If", "def min_ones(n):\n    if n == 1:\n        return 1\n    if n == 2:\n        return 2\n    dp = [0] * (n+1)\n    dp[1] = 1\n    dp[2] = 2\n    for i in range(3, n+1):\n        dp[i] = min(dp[i-1]+1, dp[i-2]+2)\n        for j in range(3, i//2+1):\n            dp[i] = min(dp[i], dp[j] + dp[i-j])\n    return dp[n]\n\nprint(min_ones(int(input())))\n\n\nThis solution uses dynamic programming to solve the problem. The dp[i] stores the minimal number of digits 1 in the sum of addends for positive integer i. For each i, it iterates through all possible j (1 \u2264 j < i), and for each j, it updates dp[i] as the minimal value between dp[i] and dp[j] + dp[i-j]. Finally, it returns dp[n].\n\nThe time complexity of this solution is O(n^2), which is feasible for n < 10^15. The space complexity is O(n), which is also feasible for n < 10^15."], "prompt": "\nQUESTION:\nProf. Vasechkin wants to represent positive integer n as a sum of addends, where each addends is an integer number containing only 1s. For example, he can represent 121 as 121=111+11+\u20131. Help him to find the least number of digits 1 in such sum.\n\n\n-----Input-----\n\nThe first line of the input contains integer n (1 \u2264 n < 10^15).\n\n\n-----Output-----\n\nPrint expected minimal number of digits 1.\n\n\n-----Examples-----\nInput\n121\n\nOutput\n6\nPlease provide the solution as pure code only, without explanations or comments.\n\nANSWER:\n```python\n"}}