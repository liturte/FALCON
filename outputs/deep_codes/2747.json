{"2747": {"code": ["class Solution:\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\n        left_idx = self.find_index(nums, target, True)\n        if left_idx == -1:\n            return [-1, -1]\n        right_idx = self.find_index(nums, target, False)\n        return [left_idx, right_idx]\n\n    def find_index(self, nums: List[int], target: int, left: bool) -> int:\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] < target:\n                left = mid + 1\n            elif nums[mid] > target:\n                right = mid - 1\n            else:\n                if left:\n                    if mid > 0 and nums[mid - 1] == target:\n                        right = mid - 1\n                    else:\n                        return mid\n                else:\n                    if mid < len(nums) - 1 and nums[mid + 1] == target:\n                        left = mid + 1\n                    else:\n                        return mid\n        return -1", "class Solution:\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\n        first = bisect.bisect_left(nums, target)\n        if first == len(nums) or nums[first] != target:\n            return [-1, -1]\n        last = bisect.bisect_right(nums, target) - 1\n        return [first, last]\n\n\nExplanation:\nWe use the built-in bisect_left and bisect_right functions from bisect module to find the position of the target. bisect_left function returns the insertion point which would be used before the target to maintain sorted order. The bisect_right function returns the insertion point which would be used after the target to maintain sorted order.\n\nThe bisect_left function will return the index of the first occurrence of the target if it exists in the list, else it will return the index where the target can be inserted to maintain the sorted order. Similarly, bisect_right will return the index of the first element greater than target if it exists in the list, else it will return the index where the target can be inserted to maintain the sorted order.\n\nIf the target is not found in the list, bisect_left will return the length of the list. We can check this by comparing", "class Solution:\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\n        first = bisect.bisect_left(nums, target)\n        if first == len(nums) or nums[first] != target:\n            return [-1, -1]\n        last = bisect.bisect_right(nums, target) - 1\n        return [first, last]\n\n\nThe bisect_left and bisect_right functions from Python's bisect module are used to find the insertion point for target in nums to maintain sorted order. bisect_left returns the first index where target can be inserted while bisect_right returns the first index after which target can be inserted.\n\nIf the target is not found in the array, bisect_left will return the length of the array, and nums[first] will not be equal to target. In this case, [-1, -1] is returned.\n\nOtherwise, bisect_right is used to find the index of the last occurrence of target, subtracting 1 to get the last index before which target can be inserted. This index is returned along with the first index of the target.\n'''\n\n# Python's bisect module is used to provide support for binary search algorithms.\n# bisect_left", "class Solution:\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\n        if not nums:\n            return [-1, -1]\n        \n        left_index = self.find_index(nums, target, True)\n        if left_index == -1:\n            return [-1, -1]\n        \n        right_index = self.find_index(nums, target, False)\n        \n        return [left_index, right_index]\n    \n    def find_index(self, nums: List[int], target: int, left: bool) -> int:\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            pivot = left + (right - left) // 2\n            if nums[pivot] > target:\n                right = pivot - 1\n            elif nums[pivot] < target:\n                left = pivot + 1\n            else:\n                if left:\n                    if pivot - 1 >=0 and nums[pivot - 1] == target:\n                        right = pivot - 1\n                    else:\n                        return pivot\n                else:\n                    if pivot + 1 < len(nums) and nums[p", "class Solution:\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\n        first = bisect.bisect_left(nums, target)\n        if first == len(nums) or nums[first] != target:\n            return [-1, -1]\n        last = bisect.bisect_right(nums, target) - 1\n        return [first, last]\n\n\nThis solution uses the bisect module which provides support for maintaining a list in sorted order without having to sort the list after each insertion operation. The bisect_left and bisect_right functions are used to find the insertion points for the target value in the sorted list.\n\nThe bisect_left function returns the insertion point which would be used before the existing items. If the item is already present, the leftmost index is returned. The bisect_right function returns the insertion point which would be used after the existing items. So if the item is already present, the rightmost index is returned.\n\nIn the solution, we first find the leftmost occurrence of the target using bisect_left. If the target is not in the list, bisect_left will return the length of the list, and the first element of the result will be -1. If the target is in the list, we check if"], "prompt": "\nQUESTION:\nGiven an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.\n\nYour algorithm's runtime complexity must be in the order of O(log n).\n\nIf the target is not found in the array, return [-1, -1].\n\nExample 1:\n\n\nInput: nums = [5,7,7,8,8,10], target = 8\nOutput: [3,4]\n\nExample 2:\n\n\nInput: nums = [5,7,7,8,8,10], target = 6\nOutput: [-1,-1]\nSTARTER CODE:\nclass Solution:\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\n\n\nPlease provide the solution as pure code only, without explanations or comments.\n\nANSWER:\n```python\n"}}