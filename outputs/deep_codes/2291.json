{"2291": {"code": ["n = int(input())\na = list(map(int, input().split()))\nprint(min(max(i ^ j for i in a) for j in range(31)))\n\n\nExplanation:\n\nThe code first reads in the number of integers and the integers themselves. It then calculates the minimum possible value of the maximum bitwise XOR for all pairs of integers in the list `a`.\n\nThe expression `max(i ^ j for i in a)` calculates the maximum bitwise XOR for all integers in `a` when XORed with `j` for all possible values of `j` (from 0 to", "def min_max_xor(n, a):\n    a.sort()\n    min_xor = float('inf')\n    for i in range(1, n):\n        min_xor = min(min_xor, a[i] ^ a[i-1])\n    return min_xor\n\nn = int(input())\na = list(map(int, input().split()))\nprint(min_max_xor(n, a))\n\nThis code works by first sorting the array of integers. Then it iterates through the sorted array and calculates the XOR of every pair of adjacent numbers. The minimum value", "n = int(input())\nnums = list(map(int, input().split()))\nprint(max(nums) ^ min(max(nums ^ x for x in range(2 ** 30)) for _ in range(2)))\n\nThis solution first reads the input. Then it calculates the minimum possible value of $\\underset{1 \\leq i \\leq n}{\\max} (a_i \\oplus X)$ for all possible $X$ in $[0, 2^{30}-1]$. The minimum of these values is the answer.\n\nNote: This solution is not optimal because it may take a lot of time", "n = int(input())\na = list(map(int, input().split()))\nprint(min(max(a_i ^ x for a_i in a) for x in range(32)))\n\n\nThis code reads the input, converts it to a list of integers, and then computes the minimum possible value of the maximum bitwise XOR for all possible values of X. It does this by iterating over all possible values of X (from 0 to 31), computing the maximum bitwise XOR for each value of X, and then choosing the minimum among these maximum values.\n\nThe bitwise XOR operation is computed using the ^ operator in", "def min_xor(n, a):\n    a.sort()\n    min_xor = float('inf')\n    for i in range(1, n):\n        min_xor = min(min_xor, a[i] ^ a[i-1])\n    return min_xor\n\nn = int(input())\na = list(map(int, input().split()))\nprint(min_xor(n, a))\n\n\nThis code first sorts the array a. Then it iterates over the sorted array to find the minimum possible XOR. The minimum XOR is initialized to infinity (float('inf')) and updated"], "prompt": "\nQUESTION:\nToday, as a friendship gift, Bakry gave Badawy $n$ integers $a_1, a_2, \\dots, a_n$ and challenged him to choose an integer $X$ such that the value $\\underset{1 \\leq i \\leq n}{\\max} (a_i \\oplus X)$ is minimum possible, where $\\oplus$ denotes the bitwise XOR operation.\n\nAs always, Badawy is too lazy, so you decided to help him and find the minimum possible value of $\\underset{1 \\leq i \\leq n}{\\max} (a_i \\oplus X)$.\n\n\n-----Input-----\n\nThe first line contains integer $n$ ($1\\le n \\le 10^5$).\n\nThe second line contains $n$ integers $a_1, a_2, \\dots, a_n$ ($0 \\le a_i \\le 2^{30}-1$).\n\n\n-----Output-----\n\nPrint one integer \u2014 the minimum possible value of $\\underset{1 \\leq i \\leq n}{\\max} (a_i \\oplus X)$.\n\n\n-----Examples-----\nInput\n3\n1 2 3\n\nOutput\n2\n\nInput\n2\n1 5\n\nOutput\n4\n\n\n\n-----Note-----\n\nIn the first sample, we can choose $X = 3$.\n\nIn the second sample, we can choose $X = 5$.\nPlease provide the solution as pure code only, without explanations or comments.\n\nANSWER:\n```python\n"}}