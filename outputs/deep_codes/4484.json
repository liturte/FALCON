{"4484": {"code": ["MOD = 10**9+7\n\ndef solve(n,m):\n    fact = [1]*(n+m+1)\n    for i in range(1,n+m+1):\n        fact[i] = (fact[i-1]*i)%MOD\n\n    invfact = [1]*(n+m+1)\n    invfact[-1] = pow(fact[-1], MOD-2, MOD)\n    for i in range(n+m, -1, -1):\n        invfact[i-1] = (invfact[i]*i)%MOD\n\n    def comb(n, r):\n        if r < 0 or n < r:\n            return 0\n        return (fact[n]*invfact[r]*invfact[n-r])", "MOD = 10**9+7\nN, M = map(int, input().split())\nfact = [1]*(N+M+1)\nfor i in range(1, N+M+1):\n    fact[i] = (fact[i-1]*i)%MOD\nprint((fact[N+M]*pow((fact[N]*fact[M])%MOD, MOD-2, MOD))%MOD)\n\n\nExplanation:\n\nThe total number of arrangements is calculated as the factorial of the total number of animals. However, the factorials of large numbers can be very large, so we need to take modulo 10^9+7 to avoid overflow.\n\nThe factorial of a number n is the product of all positive integers less than or equal to n. So, fact[i", "MOD = 10**9+7\nN, M = map(int, input().split())\n\nfact = [0]*(N+M+1)\nfactinv = [0]*(N+M+1)\n\nfact[0] = 1\nfor i in range(1, N+M+1):\n    fact[i] = fact[i-1]*i%MOD\n\nfactinv[-1] = pow(fact[-1], MOD-2, MOD)\nfor i in range(N+M, -1, -1):\n    factinv[i] = factinv[i+1]*(i+1)%MOD\n\ndef comb(n, r):\n    if n < r or r < 0:\n        return 0\n    return fact[n]*factinv[r]*factinv", "MOD = 10**9+7\nN, M = map(int, input().split())\nfact = [1]*(N+M+1)\nfor i in range(1, N+M+1):\n    fact[i] = (fact[i-1]*i)%MOD\nprint((fact[N+M]*pow(fact[N]*fact[M]%MOD, MOD-2, MOD))%MOD)\n\n\nExplanation:\nThis solution uses the concept of combinations and modular arithmetic to calculate the number of possible arrangements.\n\nFirst, we calculate the factorial of all numbers from 1 to N+M using the formula:\nfact[i] = (fact[i-1]*i)%MOD\nThis is done to prevent overflow and to avoid large numbers.\n\nThen, we", "def solve(n, m):\n    MOD = 10**9+7\n    fact = [1]*(n+m+1)\n    for i in range(1,n+m+1):\n        fact[i] = (fact[i-1]*i)%MOD\n    factinv = [1]*(n+m+1)\n    factinv[-1] = pow(fact[-1], MOD-2, MOD)\n    for i in range(n+m, -1, -1):\n        factinv[i-1] = (factinv[i]*i)%MOD\n    def comb(n, r):\n        if r < 0 or n < r:\n            return 0\n        return (fact[n]*factinv[r]*factinv[n-r])%"], "prompt": "\nQUESTION:\nSnuke has N dogs and M monkeys. He wants them to line up in a row.\nAs a Japanese saying goes, these dogs and monkeys are on bad terms. (\"ken'en no naka\", literally \"the relationship of dogs and monkeys\", means a relationship of mutual hatred.) Snuke is trying to reconsile them, by arranging the animals so that there are neither two adjacent dogs nor two adjacent monkeys.\nHow many such arrangements there are? Find the count modulo 10^9+7 (since animals cannot understand numbers larger than that).\nHere, dogs and monkeys are both distinguishable. Also, two arrangements that result from reversing each other are distinguished.\n\n-----Constraints-----\n - 1 \u2264 N,M \u2264 10^5\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN M\n\n-----Output-----\nPrint the number of possible arrangements, modulo 10^9+7.\n\n-----Sample Input-----\n2 2\n\n-----Sample Output-----\n8\n\nWe will denote the dogs by A and B, and the monkeys by C and D. There are eight possible arrangements: ACBD, ADBC, BCAD, BDAC, CADB, CBDA, DACB and DBCA.\nPlease provide the solution as pure code only, without explanations or comments.\n\nANSWER:\n```python\n"}}