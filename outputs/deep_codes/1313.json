{"1313": {"code": ["n1, n2, k1, k2 = map(int, input().split())\n\ndef can_win(n1, n2, k1, k2):\n    if n1 <= k1 and n2 <= k2:\n        return True\n    if n1 > k1 and n2 > k2:\n        return can_win(n1 - k1 - 1, n2 - k2, k1, k2)\n    return False\n\nprint(\"First\" if can_win(n1, n2, k1, k2) else \"Second\")\n\n\nThe solution works by recursively applying the game rules. If the current player", "n1, n2, k1, k2 = map(int, input().split())\nprint(\"First\" if ((n1 - 1) // k1) % 2 == 1 else \"Second\")\n\n\nThis code works by calculating the number of turns it takes for the first player to win, given his optimal play. The number of turns is determined by the formula (n_1 - 1) // k_1, where '//' is the integer division operator. The modulus operator is used to determine if the number of turns is odd or even, which determines who wins. If the number of turns is odd, the first player wins. If the number of turns is even, the second", "n_1, n_2, k_1, k_2 = map(int, input().split())\nprint(\"First\" if (n_1 - 1) % (k_2 - 1) else \"Second\")\n\n\nEXPLANATION:\nThe game is played as a mathematical problem of combinatorics. The player who has a multiple of k_2 balls left in his box wins if k_2 is less than or equal to k_1. This is because he can always reduce the number of balls in his box to a multiple of k_2 by taking away balls in his move, while the opponent can only take away balls in multiples of k_1. If k", "n1, n2, k1, k2 = map(int, input().split())\nprint(\"First\" if n1 * k1 % (n2 * k2 * (k1 - 1) + 1) else \"Second\")\n\n\nEXPLANATION:\nThe solution uses the Sprague-Grundy theorem. The Grundy function for this game is G(n) = mex { G(n - i) | i in [1, k] }. Here, mex stands for \"minimum excludant\". The game is played on the set of nim-values of the Grundy functions. The first player wins if the nim-sum of the", "def solve():\n    n1, n2, k1, k2 = map(int, input().split())\n    if n1 % (n2 + k2) <= k1:\n        print(\"First\")\n    else:\n        print(\"Second\")\n\nsolve()\n\n\nEXPLANATION:\nIn this game, the player who takes the last ball wins. In other words, if the number of remaining balls is divisible by (k1 + k2 + 1), the current player will lose. Otherwise, the current player will win. The condition is such that we can always win if we start from a position where the number of balls is divisible by (k1 +"], "prompt": "\nQUESTION:\nTwo players play a simple game. Each player is provided with a box with balls. First player's box contains exactly n_1 balls and second player's box contains exactly n_2 balls. In one move first player can take from 1 to k_1 balls from his box and throw them away. Similarly, the second player can take from 1 to k_2 balls from his box in his move. Players alternate turns and the first player starts the game. The one who can't make a move loses. Your task is to determine who wins if both players play optimally.\n\n\n-----Input-----\n\nThe first line contains four integers n_1, n_2, k_1, k_2. All numbers in the input are from 1 to 50.\n\nThis problem doesn't have subproblems. You will get 3 points for the correct submission.\n\n\n-----Output-----\n\nOutput \"First\" if the first player wins and \"Second\" otherwise.\n\n\n-----Examples-----\nInput\n2 2 1 2\n\nOutput\nSecond\n\nInput\n2 1 1 1\n\nOutput\nFirst\n\n\n\n-----Note-----\n\nConsider the first sample test. Each player has a box with 2 balls. The first player draws a single ball from his box in one move and the second player can either take 1 or 2 balls from his box in one move. No matter how the first player acts, the second player can always win if he plays wisely.\nPlease provide the solution as pure code only, without explanations or comments.\n\nANSWER:\n```python\n"}}