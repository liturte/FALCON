{"816": {"code": ["from", "from", "from", "from", "from"], "prompt": "\nQUESTION:\nThere are some beautiful girls in Arpa\u2019s land as mentioned before.\n\nOnce Arpa came up with an obvious problem:\n\nGiven an array and a number x, count the number of pairs of indices i, j (1 \u2264 i < j \u2264 n) such that $a_{i} \\oplus a_{j} = x$, where $\\oplus$ is bitwise xor operation (see notes for explanation).\n\n [Image] \n\nImmediately, Mehrdad discovered a terrible solution that nobody trusted. Now Arpa needs your help to implement the solution to that problem.\n\n\n-----Input-----\n\nFirst line contains two integers n and x (1 \u2264 n \u2264 10^5, 0 \u2264 x \u2264 10^5)\u00a0\u2014 the number of elements in the array and the integer x.\n\nSecond line contains n integers a_1, a_2, ..., a_{n} (1 \u2264 a_{i} \u2264 10^5)\u00a0\u2014 the elements of the array.\n\n\n-----Output-----\n\nPrint a single integer: the answer to the problem.\n\n\n-----Examples-----\nInput\n2 3\n1 2\n\nOutput\n1\nInput\n6 1\n5 1 2 3 4 1\n\nOutput\n2\n\n\n-----Note-----\n\nIn the first sample there is only one pair of i = 1 and j = 2. $a_{1} \\oplus a_{2} = 3 = x$ so the answer is 1.\n\nIn the second sample the only two pairs are i = 3, j = 4 (since $2 \\oplus 3 = 1$) and i = 1, j = 5 (since $5 \\oplus 4 = 1$).\n\nA bitwise xor takes two bit integers of equal length and performs the logical xor operation on each pair of corresponding bits. The result in each position is 1 if only the first bit is 1 or only the second bit is 1, but will be 0 if both are 0 or both are 1. You can read more about bitwise xor operation here: https://en.wikipedia.org/wiki/Bitwise_operation#XOR.\nPlease provide the solution as pure code only, without explanations or comments.\n\nANSWER:\n```python\n"}}