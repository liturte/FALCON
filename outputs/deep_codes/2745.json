{"2745": {"code": ["class Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        from collections import Counter\n        if not s or not words: return []\n        wordBag = Counter(words)\n        wordLen, numWord = len(words[0]), len(words)\n        totalLen, res = wordLen*numWord, []\n        for i in range(len(s)-totalLen+1):\n            seen = Counter(s[i:i+totalLen:wordLen])\n            if seen == wordBag:\n                res.append(i)\n        return res\n\n\nThe solution uses a sliding window approach. It first counts the frequency of each word in the words list using the collections.Counter class. Then it iterates over the string s, taking a substring of the length of all words concatenated together, and counts the frequency of each word in this substring. If these two counts are equal, then the substring is a valid concatenation of all words and its starting index is added to the result list.\n\nThe time complexity of this solution is O(n*m), where n is the length of", "class Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        from collections import Counter\n        if not s or not words: return []\n        wordBag = Counter(words)\n        wordLen, numWord = len(words[0]), len(words)\n        totalLen, res = wordLen*numWord, []\n        for i in range(len(s)-totalLen+1):\n            seen = Counter(s[i:i+totalLen][j:j+wordLen] for j in range(0, totalLen, wordLen))\n            if seen == wordBag:\n                res.append(i)\n        return res\n\n\nThis solution works by sliding a window of size totalLen across the string s. It then checks if the counts of the words in this window match the counts of the words in the original words list. If they do, it adds the starting index of the window to the result.\n\nIt uses the Counter class from the collections module to count the occurrences of words in the string s and the words list. The Counter class is a dictionary subclass for counting", "class Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        from collections import Counter\n        if not s or not words: return []\n        wordBag = Counter(words)\n        wordLen, numWord = len(words[0]), len(words)\n        totalLen, res = wordLen*numWord, []\n        for i in range(len(s)-totalLen+1):\n            seen = Counter(s[i:i+totalLen:wordLen])\n            if seen == wordBag:\n                res.append(i)\n        return res\n\n\nThis solution works by using a sliding window to check all possible substrings of length `totalLen` in `s`. For each substring, it slices it into words of length `wordLen` and counts the frequency of each word. If the frequency counts match the frequency counts of the words in `wordBag`, then it adds the starting index of the substring to the result list `res`. This solution has a time complexity of O(n) and a space complexity of O(m), where `n` is the length of", "class Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        from collections import Counter\n        if not s or not words: return []\n        wordBag = Counter(words)\n        wordLen, numWord = len(words[0]), len(words)\n        totalLen, res = wordLen*numWord, []\n        for i in range(len(s)-totalLen+1):\n            seen = Counter(s[i:i+totalLen:wordLen])\n            if seen == wordBag:\n                res.append(i)\n        return res\n\n\nThis solution works by first checking if the string `s` or the list of words is empty, returning an empty list if so. It then creates a Counter object for the list of words, which keeps track of the frequency of each word in the list. It also gets the length of each word and the total number of words.\n\nIt then iterates over each substring of `s` that is the length of all the words concatenated together. For each substring, it creates another Counter object to keep track of the frequency of each", "class Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        from collections import Counter\n        if not s or not words: return []\n        wordBag = Counter(words)\n        wordLen, numWord = len(words[0]), len(words)\n        totalLen, res = wordLen*numWord, []\n        for i in range(len(s)-totalLen+1):\n            seen = Counter(s[i:i+totalLen:wordLen])\n            if seen == wordBag:\n                res.append(i)\n        return res\n\n\nExplanation:\nThis solution uses a sliding window approach. First, we count the frequency of all words using the Counter from collections library. Then, for every substring of length equal to the total length of all words, we slice this string into words of length wordLen and count their frequency. If the frequency of these words matches with the frequency of words in the wordBag, we found a valid substring. We add the starting index of this substring to the result list.\n\nThe time complexity of this solution is O(n"], "prompt": "\nQUESTION:\nYou are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters.\n\nExample 1:\n\n\nInput:\ns = \"barfoothefoobarman\",\nwords = [\"foo\",\"bar\"]\nOutput: [0,9]\nExplanation: Substrings starting at index 0 and 9 are \"barfoor\" and \"foobar\" respectively.\nThe output order does not matter, returning [9,0] is fine too.\n\n\nExample 2:\n\n\nInput:\ns = \"wordgoodstudentgoodword\",\nwords = [\"word\",\"student\"]\nOutput: []\nSTARTER CODE:\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        \n\nPlease provide the solution as pure code only, without explanations or comments.\n\nANSWER:\n```python\n"}}