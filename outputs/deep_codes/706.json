{"706": {"code": ["def power(x, n, mod):\n    result = 1\n    while n > 0:\n        if n % 2 == 1:\n            result = (result * x) % mod\n        x = (x * x) % mod\n        n = n // 2\n    return result\n\ndef f(A, B, x):\n    return (A * x + B) % (10**9 + 7)\n\ndef solve(A, B, n, x):\n    return power(f(A, B, x), n, 10**9 + 7)\n\nA, B, n, x = map(int, input().split())\nprint(solve(A, B, n, x))\n\n\nThis code uses a power function that calculates the power of a number modulo", "MOD = 10**9 + 7\n\ndef solve(A, B, n, x):\n    if n == 0:\n        return x\n    elif n % 2 == 0:\n        return solve(A*A % MOD, (A*B + B) % MOD, n//2, x)\n    else:\n        return solve(A, B, n-1, (A*x + B) % MOD)\n\nA, B, n, x = map(int, input().split())\nprint(solve(A, B, n, x))\n\n\nIn this solution, we use the concept of exponentiation by squaring to solve the problem efficiently. The base case of the recursion is when n = 0, in which case we return x. If n is even, we square the", "MOD = 10**9 + 7\n\ndef powmod(a, b):\n    if b == 0:\n        return 1\n    elif b % 2 == 0:\n        return powmod((a*a) % MOD, b//2)\n    else:\n        return (a * powmod((a*a) % MOD, b//2)) % MOD\n\ndef f(A, B, n, x):\n    if n == 0:\n        return x % MOD\n    else:\n        return (powmod(A, n) * x + B * powmod(A, n-1) * n) % MOD\n\nA, B, n, x = map(int, input().split())\nprint(f(A, B, n, x))", "MOD = 10**9 + 7\n\ndef f(a, b, x):\n    return (a*x + b) % MOD\n\ndef g(a, b, n, x):\n    if n == 0:\n        return x\n    else:\n        return f(a, b, g(a, b, n-1, x))\n\na, b, n, x = map(int, input().split())\nprint(g(a, b, n, x))\n\nThis code defines the function `f(x)` as Ax + B modulo 10^9 + 7. It then defines the recursive function `g(n)` which applies `f(x)` to the result of `g(n-1)`. If n is 0, it simply", "MOD = 10**9 + 7\n\ndef power(base, n):\n    res = 1\n    while n > 0:\n        if n % 2 == 1:\n            res = (res * base) % MOD\n        base = (base * base) % MOD\n        n = n // 2\n    return res\n\ndef f(a, b, x, n):\n    if n == 0:\n        return x\n    else:\n        return power(a, n * b)\n\nA, B, n, x = map(int, input().split())\nprint(f(A, B, x, n))\n\nThis python code firstly calculates the power of a number using binary exponentiation. Then it uses this power function to calculate the nth power of the function f(x"], "prompt": "\nQUESTION:\nConsider a linear function f(x) = Ax + B. Let's define g^{(0)}(x) = x and g^{(}n)(x) = f(g^{(}n - 1)(x)) for n > 0. For the given integer values A, B, n and x find the value of g^{(}n)(x) modulo 10^9 + 7.\n\n\n-----Input-----\n\nThe only line contains four integers A, B, n and x (1 \u2264 A, B, x \u2264 10^9, 1 \u2264 n \u2264 10^18) \u2014 the parameters from the problem statement.\n\nNote that the given value n can be too large, so you should use 64-bit integer type to store it. In C++ you can use the long long integer type and in Java you can use long integer type.\n\n\n-----Output-----\n\nPrint the only integer s \u2014 the value g^{(}n)(x) modulo 10^9 + 7.\n\n\n-----Examples-----\nInput\n3 4 1 1\n\nOutput\n7\n\nInput\n3 4 2 1\n\nOutput\n25\n\nInput\n3 4 3 1\n\nOutput\n79\nPlease provide the solution as pure code only, without explanations or comments.\n\nANSWER:\n```python\n"}}