{"4687": {"code": ["import sys\nfrom bisect import bisect_right\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\n\nn, k = map(int, readline().split())\nab = [list(map(int, readline().split())) for _ in range(n)]\n\nl = []\nfor a, b in ab:\n    l.extend([a]*b)\n\nl.sort()\nprint(l[k-1])\n\n\nThis program uses a list to store the integers a_i. For each operation, it adds b_i copies of a_i to the list. The list is then sorted in ascending order. The K-th smallest integer is then printed from the sorted list.\n\nThe bisect_right function from the bisect module is used to find the insertion point for a", "from sys import stdin\nfrom bisect import bisect_right\n\nN, K = map(int, stdin.readline().split())\nA = []\nB = []\nfor _ in range(N):\n    a, b = map(int, stdin.readline().split())\n    A.append(a)\n    B.append(b)\n\nlo = min(A)\nhi = max(A) * max(B)\nwhile lo < hi:\n    mid = (lo + hi) // 2\n    if sum(bisect_right(A, mid) * b for b in B) < K:\n        lo = mid + 1\n    else:\n        hi = mid\nprint(lo)\n\n\nEXPLANATION:\nThis problem is a binary search problem.\nThe binary search is performed on the range of possible answers.\nThe range is from", "import sys\nfrom bisect import bisect_left, insort_left\n\ninput = sys.stdin.readline\nn, k = map(int, input().split())\na = [0] * n\nb = [0] * n\nc = []\n\nfor i in range(n):\n    a[i], b[i] = map(int, input().split())\n    insort_left(c, a[i])\n    if len(c) > b[i]:\n        del c[bisect_left(c, a[i])]\n\nprint(c[k - 1])\n\nThis python code takes the number of operations `n` and the `k`-th smallest number as inputs. It then takes `n` lines of inputs, each containing an integer `a[i]` and its frequency `b[i]`. For each line,", "import sys\nfrom bisect import bisect_left\n\ndef solve():\n    N, K = map(int, sys.stdin.readline().split())\n    A = []\n    for _ in range(N):\n        a, b = map(int, sys.stdin.readline().split())\n        A.append((a, b))\n    A.sort()\n    counts = []\n    for a, b in A:\n        if not counts or counts[-1][0] != a:\n            counts.append((a, b))\n        else:\n            counts[-1] = (a, counts[-1][1]+b)\n    prefix_sums = [0]\n    for _, b in counts:\n        prefix_sums.append(prefix_sums[-1] + b)\n    if K > prefix_sums[-1]:\n        print", "import sys\nfrom bisect import bisect_left\n\nn, k = map(int, sys.stdin.readline().split())\nab = [list(map(int, sys.stdin.readline().split())) for _ in range(n)]\n\nnums = []\ncnts = []\nfor a, b in ab:\n    nums.append(a)\n    cnts.append(b)\n\nN = sum(cnts)\n\nl = 0\nr = max(nums) + 1\nwhile r - l > 1:\n    m = (r + l) // 2\n    c = sum(min(b, m // a) for a, b in zip(nums, cnts))\n    if c >= k:\n        r = m\n    else:\n        l = m\n\nprint(r)"], "prompt": "\nQUESTION:\nThere is an empty array.\nThe following N operations will be performed to insert integers into the array.\nIn the i-th operation (1\u2264i\u2264N), b_i copies of an integer a_i are inserted into the array.\nFind the K-th smallest integer in the array after the N operations.\nFor example, the 4-th smallest integer in the array \\{1,2,2,3,3,3\\} is 3.\n\n-----Constraints-----\n - 1\u2264N\u226410^5 \n - 1\u2264a_i,b_i\u226410^5 \n - 1\u2264K\u2264b_1\u2026+\u2026b_n\n - All input values are integers.\n\n-----Input-----\nInput is given from Standard Input in the following format:  \nN K\na_1 b_1\n:  \na_N b_N\n\n-----Output-----\nPrint the K-th smallest integer in the array after the N operations.  \n\n-----Sample Input-----\n3 4\n1 1\n2 2\n3 3\n\n-----Sample Output-----\n3\n\nThe resulting array is the same as the one in the problem statement.\nPlease provide the solution as pure code only, without explanations or comments.\n\nANSWER:\n```python\n"}}