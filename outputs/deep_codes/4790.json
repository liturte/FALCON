{"4790": {"code": ["def is_balanced(s):\n    s = s + s\n    black = s.count('B')\n    white = s.count('W')\n    for i in range(len(s)//2):\n        if black == white == 1:\n            return 1\n        if s[i] == 'B':\n            black -= 1\n        else:\n            white -= 1\n        if s[i+black+white+1] == 'B':\n            black += 1\n        else:\n            white += 1\n    return 0\n\nprint(is_balanced(input()))\n\n\nThis solution works by creating a double string of the input to allow for circular checking. It then iterates over the double string, keeping track of the current number of black and white stones. If at any point there are exactly one black", "def is_balanced(s):\n    black = s.count('B')\n    white = s.count('W')\n    if abs(black - white) > 1:\n        return 0\n    if black > white:\n        return s.count('BW') >= black - white\n    if white > black:\n        return s.count('WB') >= white - black\n    return 1\n\ns = input()\nprint(is_balanced(s))\n\n\nThe code counts the number of black and white stones in the input string. If the difference in the number of black and white stones is greater than 1, it is impossible to balance the stones. If the number of black stones is more than the number of white stones, it checks if there are enough consecutive sequences of white stones that can be replaced with a single black stone.", "def check_balance(s):\n    b = s.count('B')\n    w = s.count('W')\n    if abs(b - w) > 1:\n        return 0\n    else:\n        return 1\n\ns = input()\nprint(check_balance(s))\n\n\nThis solution works by counting the number of black and white stones in the string. If the difference between the number of black and white stones is greater than 1, it is not possible to balance the stones, so the function returns 0. Otherwise, it returns 1.\n\nPlease note that this solution assumes that the stones are arranged in a circular arrangement, as stated in the problem. If the stones are not arranged in a circular arrangement, the solution may not work correctly.\n\nAlso note that this solution assumes that the stones are arranged in a single string,", "def balance_stones(s):\n    b = s.count('B')\n    w = s.count('W')\n    if abs(b - w) > 1:\n        return 0\n    else:\n        return 1\n\ns = input()\nprint(balance_stones(s))\n\n\nThis solution works by counting the number of black and white stones in the input string. If the difference between the number of black and white stones is more than 1, it means that the stones cannot be balanced and the function returns 0. Otherwise, it returns 1.\n\nThis solution has a time complexity of O(n) because it goes through the input string once to count the number of black and white stones.\n\nThe space complexity is O(1) because it only stores the count of black and white stones and does not use any additional", "def balance_stones(s):\n    b = s.count('B')\n    w = s.count('W')\n    return abs(b - w) <= 1\n\ns = input()\nprint(int(balance_stones(s)))\n\n\nThis solution works by counting the number of black stones and white stones in the string. It then checks if the difference between the two counts is less than or equal to 1. If the difference is less than or equal to 1, it means that there is at most one more black stone than white stone or vice versa, so it is possible for Ming to balance the stones. Otherwise, it is not possible. The int function is used to convert the boolean result to an integer (1 for True, 0 for False) because the problem requires the output to be an integer."], "prompt": "\nQUESTION:\nA mysterious circular arrangement of black stones and white stones has appeared. Ming has been tasked with balancing the stones so that only one black and one white stone remain.\n\nMing has two operations for balancing the stones:\n - Take some consecutive sequence of stones where there is exactly one more black stone than a white stone and replace the stones with a single black stone\n - Take some consecutive sequence of stones where there is exactly one more white stone than black stone and replace the stones with a single white stone\n\nGiven a circular arrangement, determine if it is possible for Ming to balance the stones.\n\n-----Input-----\nEach input will consist of a single test case. Note that your program may be run multiple times on different inputs. The input will consist of a single string $s$ ($1 \\le |s| \\le 10^5$), with only the characters capital \u2018B\u2019 and \u2018W\u2019. The stones are arranged in a circle, so the first stone and the last stone are adjacent.\n\n-----Output-----\nOutput $1$ if it is possible for Ming to balance the stones with his rules. Otherwise, output $0$.\n\n-----Examples-----\nSample Input 1:\nWWBWBB\nSample Output 1:\n1\n\nSample Input 2:\nWWWWBBW\nSample Output 2:\n0\nPlease provide the solution as pure code only, without explanations or comments.\n\nANSWER:\n```python\n"}}