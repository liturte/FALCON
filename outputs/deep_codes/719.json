{"719": {"code": ["def find_perfect(k):\n    count = 0\n    number = 1\n    while True:\n        if sum(map(int, str(number))) == 10:\n            count += 1\n            if count == k:\n                return number\n        number += 1\n\nk = int(input())\nprint(find_perfect(k))\n\n\nEXPLANATION:\nThis code defines a function find_perfect() that takes an integer k as input and returns the k-th perfect number. The function starts with a count of 0 and a number of 1. It then enters a while loop that continues until it finds the k-th perfect number. If the sum of the digits of the current number is 10 (which means it is a perfect number), it increments the count. If the count equals k, it returns the current number, which is the k-th perfect number. If the sum of the digits is not 10, it increments the number and continues the loop. The main part of the code reads an integer k from the input, calls the find_perfect() function with k as the argument, and prints the result.\n\nThis code assumes that the perfect numbers are positive integers. If the perfect numbers can also be negative, the code would need to be modified to handle that case.", "import heapq\n\ndef find_next_perfect(n):\n    digits = list(str(n))\n    for i in range(len(digits)):\n        for j in range(i + 1, len(digits)):\n            digits[i], digits[j] = digits[j], digits[i]\n            num = int(''.join(digits))\n            if sum(map(int, str(num))) == 10:\n                return num\n            digits[i], digits[j] = digits[j], digits[i]\n    return None\n\ndef solve(k):\n    heap = [19]\n    visited = {19}\n    for _ in range(k - 1):\n        n = heapq.heappop(heap)\n        while True:\n            next_n = find_next_perfect(n + 1)\n            if next_n is None:\n                n += 1\n            else:\n                break\n        heapq.heappush(heap, next_n)\n        visited.add(next_n)\n    return heap[0]\n\nprint(solve(int(input().strip())))\n\n\nThis code uses a priority queue to keep track of the smallest perfect numbers. It starts from 19 (the first perfect number), and for each number, it finds the next perfect number", "from heapq import *\n\ndef nth_perfect(n):\n    heap = [(1, 19)]\n    visited = {19}\n    while heap:\n        _, num = heappop(heap)\n        if num > 10000:\n            continue\n        if sum(int(d) for d in str(num)) == 10:\n            if n == 1:\n                return num\n            n -= 1\n        for digit in range(0, 10):\n            new_num = num * 10 + digit\n            if new_num not in visited and sum(int(d) for d in str(new_num)) == 10:\n                visited.add(new_num)\n                heappush(heap, (new_num, new_num))\n\nprint(nth_perfect(int(input())))\n\nThis Python code uses a heap to keep track of the smallest numbers that have a sum of digits equal to 10. It starts from 19 and generates all numbers that can be formed by appending a digit to the end of the current number. If the sum of the digits of the new number is 10, it is added to the heap. The function nth_perfect returns the n-th smallest number that has a sum of digits equal to 10.\n\nThis code uses a heap and a set to avoid generating", "from heapq import *\n\ndef nthUglyNumber(n):\n    uglies = []\n    heapify(uglies)\n    heappush(uglies, 1)\n    i, j, k = 0, 0, 0\n    while len(uglies) < n + 1:\n        while uglies[0] == uglies[1]:\n            heappop(uglies)\n        x = heappop(uglies)\n        heappush(uglies, x * 2)\n        heappush(uglies, x * 3)\n        heappush(uglies, x * 5)\n    return uglies[n]\n\ndef sumOfDigits(n):\n    return sum(map(int, str(n)))\n\ni = 1\nwhile True:\n    num = nthUglyNumber(i)\n    if sumOfDigits(num) == 10:\n        i += 1\n        if i > 10000:\n            break\nprint(num)\n\nThis code uses a heap to keep track of the smallest ugly numbers. The ugly numbers are generated by multiplying the smallest ugly number by 2, 3, and 5, and then pushing the new numbers onto the heap. The heap ensures that the smallest number is always at the top of the heap. The code also checks the sum of the digits of each number to", "def kth_smallest_perfect(k):\n    i = 19\n    count = 0\n    while True:\n        if sum(int(digit) for digit in str(i)) == 10:\n            count += 1\n            if count == k:\n                return i\n        i += 1\n\nk = int(input())\nprint(kth_smallest_perfect(k))\n\n\nThis Python program uses a while loop to iterate through positive integers. For each integer, it checks if the sum of its digits is 10. If it is, it increments a count variable. When the count reaches the input value of k, it returns the current integer.\n\nThis program assumes that the input is a positive integer and that k is less than or equal to 10,000. If these conditions are not met, the program may not work correctly.\n\nPlease note that this program may take a while to run for larger values of k because it checks each positive integer one by one."], "prompt": "\nQUESTION:\nWe consider a positive integer perfect, if and only if the sum of its digits is exactly $10$. Given a positive integer $k$, your task is to find the $k$-th smallest perfect positive integer.\n\n\n-----Input-----\n\nA single line with a positive integer $k$ ($1 \\leq k \\leq 10\\,000$).\n\n\n-----Output-----\n\nA single number, denoting the $k$-th smallest perfect integer.\n\n\n-----Examples-----\nInput\n1\n\nOutput\n19\n\nInput\n2\n\nOutput\n28\n\n\n\n-----Note-----\n\nThe first perfect integer is $19$ and the second one is $28$.\nPlease provide the solution as pure code only, without explanations or comments.\n\nANSWER:\n```python\n"}}