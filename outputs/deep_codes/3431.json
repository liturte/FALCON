{"3431": {"code": ["import heapq\n\ndef solve(n, points):\n    edges = []\n    for i in range(n):\n        x1, y1 = points[i]\n        for j in range(i + 1, n):\n            x2, y2 = points[j]\n            d = abs(x1 - x2) + abs(y1 - y2)\n            edges.append((d, (i, j)))\n    edges.sort()\n    parent = list(range(n))\n    size = [1] * n\n    result = 0\n    for d, (i, j) in edges:\n        if find(i, parent) != find(j, parent):\n            union(i, j, parent, size)\n            result += d\n    return result\n\ndef find(x, parent):\n    if x != parent[x]:\n        parent[x] = find(parent[x], parent)\n    return parent[x]\n\ndef union(x, y, parent, size):\n    x = find(x, parent)\n    y = find(y, parent)\n    if x != y:\n        if size[x] < size[y]:", "from heapq import *\n\ndef solve():\n    n = int(input())\n    points = [tuple(map(int, input().split())) for _ in range(n)]\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            x1, y1 = points[i]\n            x2, y2 = points[j]\n            d = abs(x1 - x2) + abs(y1 - y2)\n            heappush(edges, (d, i, j))\n    parent = list(range(n))\n    def find(i):\n        if parent[i] != i:\n            parent[i] = find(parent[i])\n        return parent[i]\n    total = 0\n    while edges:\n        d, i, j = heappop(edges)\n        if find(i) != find(j):\n            total += d\n            parent[find(i)] = find(j)\n    print(total)\n\nsolve()\n\n\nExplanation:\nThis solution uses Kruskal's algorithm to find the Minimum Spanning Tree", "import heapq\n\ndef solve(n, points):\n    edges = []\n    for i in range(n):\n        x1, y1 = points[i]\n        for j in range(i+1, n):\n            x2, y2 = points[j]\n            distance = abs(x1 - x2) + abs(y1 - y2)\n            edges.append((distance, (i, j)))\n\n    edges.sort()\n\n    parent = list(range(n))\n    rank = [0] * n\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        x, y = find(x), find(y)\n        if x == y:\n            return False\n        if rank[x] > rank[y]:\n            x, y = y, x\n        parent[x] = y\n        if rank[x] == rank[y]:\n            rank[y] += 1\n        return True\n\n    total_distance = 0\n    for distance, (x, y) in edges:", "import heapq\n\ndef solve():\n    N = int(input())\n    points = []\n    for _ in range(N):\n        x, y = map(int, input().split())\n        points.append((x, y))\n\n    # Create a priority queue for the edges\n    edges = []\n    for i in range(N):\n        x1, y1 = points[i]\n        for j in range(i+1, N):\n            x2, y2 = points[j]\n            # Manhattan distance\n            weight = abs(x1 - x2) + abs(y1 - y2)\n            heapq.heappush(edges, (weight, i, j))\n\n    # Initialize the disjoint set\n    parent = list(range(N))\n    rank = [0] * N\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        xr = find(x)\n        yr = find(y)\n        if rank[xr] < rank[yr]:\n            parent", "def kruskal(edges, n):\n    edges.sort()\n    parent = list(range(n))\n    rank = [0] * n\n    weight = 0\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y, w):\n        nonlocal weight\n        x, y = find(x), find(y)\n        if x != y:\n            weight += w\n            if rank[x] < rank[y]:\n                x, y = y, x\n            if rank[x] == rank[y]:\n                rank[x] += 1\n            parent[y] = x\n\n    for x, y, w in edges:\n        union(x, y, w)\n\n    return weight\n\nn = int(input())\npoints = [tuple(map(int, input().split())) for _ in range(n)]\nedges = []\nfor i in range(n):\n    for j in range(i + 1, n):\n        x1, y1 = points[i]\n        x2"], "prompt": "\nQUESTION:\nThis is a very simple problem. You are given $N$ points. Some points may be repeated. The weight (distance) between two points is given by the Manhattan distance between the two points. Find the weight of a Minimum Spanning Tree that spans these $N$ points.\n\n-----Input-----\nThe input consists of:\n - One line with one integer $N$ ($1 \\leq N \\leq 100000$), the number of points,\n - $N$ lines each with two integers $x$ and $y$ ($0 \\leq x,y < 1000$), the coordinates of each point.\n\n-----Output-----\nOutput one line with a single integer: The weight of a Minimum Spanning Tree that spans these $N$ points.\n\n-----Examples-----\nSample Input:\n4\n0 0\n0 1\n1 0\n1 1\nSample Output:\n3\nPlease provide the solution as pure code only, without explanations or comments.\n\nANSWER:\n```python\n"}}