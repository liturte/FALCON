{"150": {"code": ["def min_tax(n):\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n\n\nn = int(input())\nprint(min_tax(n))\n\nThis Python code uses a simple mathematical fact: a number's largest prime factor is less than or equal to its square root. So, it divides the number by all integers from", "def min_tax(n):\n    if n == 2:\n        return 1\n    if n % 2 == 0:\n        return n // 2\n    else:\n        return n\n\nn = int(input().strip())\nprint(min_tax(n))\n\n\nExplanation:\nThis problem is a simple implementation of the Sieve of Eratosthenes algorithm. The Sieve of Eratosthenes is an algorithm used to", "def min_tax(n):\n    if n == 1:\n        return 1\n    else:\n        return 1 + min_tax(n // 2)\n\nn = int(input())\nprint(min_tax(n))\n\n\nExplanation:\nThe function min_tax(n) calculates the minimum number of burles that Mr. Funt has to pay as a tax. If n is 1, the function returns 1,", "def min_tax(n):\n    return n if n % 2 == 0 else n + 1\n\nn = int(input().strip())\nprint(min_tax(n))\n\nThis code takes an integer input n and checks if it is even. If it is, it returns n. If it is not, it returns n + 1. This is because the maximum divisor of an even number is half of the number, and the maximum divisor of an odd number is", "def min_tax(n):\n    if n == 1:\n        return 1\n    else:\n        return 1 + min_tax(n // 2)\n\nprint(min_tax(int(input())))\n\n\nThis solution uses a recursive function to calculate the minimum number of burles Funt has to pay. It works by repeatedly dividing the total income by 2 and adding 1 to the tax each time, until the total income is"], "prompt": "\nQUESTION:\nMr. Funt now lives in a country with a very specific tax laws. The total income of mr. Funt during this year is equal to n (n \u2265 2) burles and the amount of tax he has to pay is calculated as the maximum divisor of n (not equal to n, of course). For example, if n = 6 then Funt has to pay 3 burles, while for n = 25 he needs to pay 5 and if n = 2 he pays only 1 burle.\n\nAs mr. Funt is a very opportunistic person he wants to cheat a bit. In particular, he wants to split the initial n in several parts n_1 + n_2 + ... + n_{k} = n (here k is arbitrary, even k = 1 is allowed) and pay the taxes for each part separately. He can't make some part equal to 1 because it will reveal him. So, the condition n_{i} \u2265 2 should hold for all i from 1 to k.\n\nOstap Bender wonders, how many money Funt has to pay (i.e. minimal) if he chooses and optimal way to split n in parts.\n\n\n-----Input-----\n\nThe first line of the input contains a single integer n (2 \u2264 n \u2264 2\u00b710^9)\u00a0\u2014 the total year income of mr. Funt.\n\n\n-----Output-----\n\nPrint one integer\u00a0\u2014 minimum possible number of burles that mr. Funt has to pay as a tax.\n\n\n-----Examples-----\nInput\n4\n\nOutput\n2\n\nInput\n27\n\nOutput\n3\nPlease provide the solution as pure code only, without explanations or comments.\n\nANSWER:\n```python\n"}}