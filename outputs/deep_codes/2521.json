{"2521": {"code": ["from sys import stdin\nfrom heapq import nlargest\n\nN = int(stdin.readline().strip())\nA = list(map(int, stdin.readline().strip().split()))\n\nfirst_half_sum = sum(A[:N])\nsecond_half_sum = sum(A[N:2*N])\nmax_diff = 0\n\nfor i in range(N, 2*N):\n    new_sum = first_half_sum - A[i] + A[i+N]\n    diff = new_sum - second_half_sum\n    if diff > max_diff:\n        max_diff = diff\n        second_half", "import sys\nfrom heapq import *\n\nN = int(sys.stdin.readline().strip())\nA = list(map(int, sys.stdin.readline().strip().split()))\n\nminus_heap, plus_heap = [], []\nfor i in range(3*N):\n    if A[i] < 0:\n        heappush(minus_heap, A[i])\n    else:\n        heappush(plus_heap, -A[i])\n\nscore = 0\nwhile len(minus_heap) > N:\n    score += heappop(minus_heap)\nwhile len(plus_heap) >", "def solve():\n    N = int(input())\n    A = list(map(int, input().split()))\n\n    A.sort()\n    print(sum(A[:N]) - sum(A[N:-N]))\n\nsolve()\n\n\nEXPLANATION:\nThis problem is a simple variation of the problem \"Maximize Sum of Product\".\n\nThe main idea is to sort the sequence and select the N smallest elements in the first half of the sequence and the N largest elements in the second half of the sequence.\n\nThe score of a' is calculated as the sum of the elements in the first half of a' minus the sum of the elements in the second half of a'.", "import heapq\n\nN = int(input())\nA = list(map(int, input().split()))\n\nleft_half = A[:N]\nright_half = A[N:2*N]\n\nleft_min_heap = left_half[:N//2]\nright_min_heap = right_half[:N//2]\nleft_max_heap = [-a for a in left_half[N//2:]]\nright_max_heap = [-a for a in right_half[N//2:]]\n\nheapq.heapify(left_min_heap)\nheapq.heapify(right_min_", "import sys\n\ndef max_score():\n    n = int(sys.stdin.readline().strip())\n    a = list(map(int, sys.stdin.readline().strip().split()))\n\n    # calculate the sum of all elements\n    total_sum = sum(a)\n\n    # sort the list in ascending order\n    a.sort()\n\n    # calculate the sum of the first N elements\n    first_half_sum = sum(a[:n])\n\n    # calculate the sum of the last N elements\n    second_half_sum = sum(a[n:-n])\n\n    # calculate the sum of the remaining elements\n    remaining_sum"], "prompt": "\nQUESTION:\nLet N be a positive integer.\nThere is a numerical sequence of length 3N, a = (a_1, a_2, ..., a_{3N}).\nSnuke is constructing a new sequence of length 2N, a', by removing exactly N elements from a without changing the order of the remaining elements.\nHere, the score of a' is defined as follows: (the sum of the elements in the first half of a') - (the sum of the elements in the second half of a').\nFind the maximum possible score of a'.\n\n-----Constraints-----\n - 1 \u2264 N \u2264 10^5\n - a_i is an integer.\n - 1 \u2264 a_i \u2264 10^9\n\n-----Partial Score-----\n - In the test set worth 300 points, N \u2264 1000.\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN\na_1 a_2 ... a_{3N}\n\n-----Output-----\nPrint the maximum possible score of a'.\n\n-----Sample Input-----\n2\n3 1 4 1 5 9\n\n-----Sample Output-----\n1\n\nWhen a_2 and a_6 are removed, a' will be (3, 4, 1, 5), which has a score of (3 + 4) - (1 + 5) = 1.\nPlease provide the solution as pure code only, without explanations or comments.\n\nANSWER:\n```python\n"}}