{"984": {"code": ["QUESTION:\nLet T be arbitrary binary tree \u2014 tree, every vertex of which has no more than two children. Given tree is rooted, so there exists only one vertex which doesn't have a parent \u2014 it's the root of a tree. Every vertex has an integer number written on it. Following algorithm is run on every value from the tree T:  Set pointer to the root of a tree.  Return success if the value in the current vertex is equal to the number you are looking for  Go to the left child of the vertex if the value in the current vertex is greater than the number you are looking for  Go to the right child of the vertex if the value in the current vertex is less than the number you are looking for  Return fail if you try to go to the vertex that doesn't exist \n\nHere is the pseudo-code of the described algorithm: \n\nbool find(TreeNode t, int x) {\n\n    if (t == null)\n\n        return false;\n\n    if (t.value == x)\n\n        return true;\n\n    if (x < t.value)\n\n        return find(t.left, x);\n\n    else\n\n        return find(t.right, x);\n\n}\n\nfind(root, x);\n\n\n\nThe described algorithm works correctly if the tree is binary search tree (i.e. for each node the values of left subtree are less than the value in the node, the values of right subtree are greater than the value in the node). But it can return invalid result if tree is not a binary search tree.\n\nSince the given tree is not necessarily a binary search tree, not all numbers can be found this way. Your task is to calculate, how many times the search will fail being running on every value from the tree.\n\nIf the tree has multiple vertices with the same values on them then you should run algorithm on every one of them separately.\n\n\n-----Input-----\n\nFirst line contains integer number n (1 \u2264 n \u2264 10^5) \u2014 number of vertices in the tree.\n\nEach of the next n lines contains 3 numbers v, l, r (0 \u2264 v \u2264 10^9) \u2014 value on current vertex, index of the left child of the vertex and index of the right child of the vertex, respectively. If some child doesn't exist then number  - 1 is set instead. Note that different vertices of the tree may contain the same values.\n\n\n-----Output-----\n\nPrint number of times when search algorithm will fail.\n\n\n-----Examples-----\nInput\n3\n15 -1 -1\n10 1 3\n5 -", "QUESTION:\nLet T be arbitrary binary tree \u2014 tree, every vertex of which has no more than two children. Given tree is rooted, so there exists only one vertex which doesn't have a parent \u2014 it's the root of a tree. Every vertex has an integer number written on it. Following algorithm is run on every value from the tree T:  Set pointer to the root of a tree.  Return success if the value in the current vertex is equal to the number you are looking for  Go to the left child of the vertex if the value in the current vertex is greater than the number you are looking for  Go to the right child of the vertex if the value in the current vertex is less than the number you are looking for  Return fail if you try to go to the vertex that doesn't exist \n\nHere is the pseudo-code of the described algorithm: \n\nbool find(TreeNode t, int x) {\n\n    if (t == null)\n\n        return false;\n\n    if (t.value == x)\n\n        return true;\n\n    if (x < t.value)\n\n        return find(t.left, x);\n\n    else\n\n        return find(t.right, x);\n\n}\n\nfind(root, x);\n\n\n\nThe described algorithm works correctly if the tree is binary search tree (i.e. for each node the values of left subtree are less than the value in the node, the values of right subtree are greater than the value in the node). But it can return invalid result if tree is not a binary search tree.\n\nSince the given tree is not necessarily a binary search tree, not all numbers can be found this way. Your task is to calculate, how many times the search will fail being running on every value from the tree.\n\nIf the tree has multiple vertices with the same values on them then you should run algorithm on every one of them separately.\n\n\n-----Input-----\n\nFirst line contains integer number n (1 \u2264 n \u2264 10^5) \u2014 number of vertices in the tree.\n\nEach of the next n lines contains 3 numbers v, l, r (0 \u2264 v \u2264 10^9) \u2014 value on current vertex, index of the left child of the vertex and index of the right child of the vertex, respectively. If some child doesn't exist then number  - 1 is set instead. Note that different vertices of the tree may contain the same values.\n\n\n-----Output-----\n\nPrint number of times when search algorithm will fail.\n\n\n-----Examples-----\nInput\n3\n15 -1 -1\n10 1 3\n5 -", "QUESTION:\nLet T be arbitrary binary tree \u2014 tree, every vertex of which has no more than two children. Given tree is rooted, so there exists only one vertex which doesn't have a parent \u2014 it's the root of a tree. Every vertex has an integer number written on it. Following algorithm is run on every value from the tree T:  Set pointer to the root of a tree.  Return success if the value in the current vertex is equal to the number you are looking for  Go to the left child of the vertex if the value in the current vertex is greater than the number you are looking for  Go to the right child of the vertex if the value in the current vertex is less than the number you are looking for  Return fail if you try to go to the vertex that doesn't exist \n\nHere is the pseudo-code of the described algorithm: \n\nbool find(TreeNode t, int x) {\n\n    if (t == null)\n\n        return false;\n\n    if (t.value == x)\n\n        return true;\n\n    if (x < t.value)\n\n        return find(t.left, x);\n\n    else\n\n        return find(t.right, x);\n\n}\n\nfind(root, x);\n\n\n\nThe described algorithm works correctly if the tree is binary search tree (i.e. for each node the values of left subtree are less than the value in the node, the values of right subtree are greater than the value in the node). But it can return invalid result if tree is not a binary search tree.\n\nSince the given tree is not necessarily a binary search tree, not all numbers can be found this way. Your task is to calculate, how many times the search will fail being running on every value from the tree.\n\nIf the tree has multiple vertices with the same values on them then you should run algorithm on every one of them separately.\n\n\n-----Input-----\n\nFirst line contains integer number n (1 \u2264 n \u2264 10^5) \u2014 number of vertices in the tree.\n\nEach of the next n lines contains 3 numbers v, l, r (0 \u2264 v \u2264 10^9) \u2014 value on current vertex, index of the left child of the vertex and index of the right child of the vertex, respectively. If some child doesn't exist then number  - 1 is set instead. Note that different vertices of the tree may contain the same values.\n\n\n-----Output-----\n\nPrint number of times when search algorithm will fail.\n\n\n-----Examples-----\nInput\n3\n15 -1 -1\n10 1 3\n5 -", "QUESTION:\nLet T be arbitrary binary tree \u2014 tree, every vertex of which has no more than two children. Given tree is rooted, so there exists only one vertex which doesn't have a parent \u2014 it's the root of a tree. Every vertex has an integer number written on it. Following algorithm is run on every value from the tree T:  Set pointer to the root of a tree.  Return success if the value in the current vertex is equal to the number you are looking for  Go to the left child of the vertex if the value in the current vertex is greater than the number you are looking for  Go to the right child of the vertex if the value in the current vertex is less than the number you are looking for  Return fail if you try to go to the vertex that doesn't exist \n\nHere is the pseudo-code of the described algorithm: \n\nbool find(TreeNode t, int x) {\n\n    if (t == null)\n\n        return false;\n\n    if (t.value == x)\n\n        return true;\n\n    if (x < t.value)\n\n        return find(t.left, x);\n\n    else\n\n        return find(t.right, x);\n\n}\n\nfind(root, x);\n\n\n\nThe described algorithm works correctly if the tree is binary search tree (i.e. for each node the values of left subtree are less than the value in the node, the values of right subtree are greater than the value in the node). But it can return invalid result if tree is not a binary search tree.\n\nSince the given tree is not necessarily a binary search tree, not all numbers can be found this way. Your task is to calculate, how many times the search will fail being running on every value from the tree.\n\nIf the tree has multiple vertices with the same values on them then you should run algorithm on every one of them separately.\n\n\n-----Input-----\n\nFirst line contains integer number n (1 \u2264 n \u2264 10^5) \u2014 number of vertices in the tree.\n\nEach of the next n lines contains 3 numbers v, l, r (0 \u2264 v \u2264 10^9) \u2014 value on current vertex, index of the left child of the vertex and index of the right child of the vertex, respectively. If some child doesn't exist then number  - 1 is set instead. Note that different vertices of the tree may contain the same values.\n\n\n-----Output-----\n\nPrint number of times when search algorithm will fail.\n\n\n-----Examples-----\nInput\n3\n15 -1 -1\n10 1 3\n5 -", "QUESTION:\nLet T be arbitrary binary tree \u2014 tree, every vertex of which has no more than two children. Given tree is rooted, so there exists only one vertex which doesn't have a parent \u2014 it's the root of a tree. Every vertex has an integer number written on it. Following algorithm is run on every value from the tree T:  Set pointer to the root of a tree.  Return success if the value in the current vertex is equal to the number you are looking for  Go to the left child of the vertex if the value in the current vertex is greater than the number you are looking for  Go to the right child of the vertex if the value in the current vertex is less than the number you are looking for  Return fail if you try to go to the vertex that doesn't exist \n\nHere is the pseudo-code of the described algorithm: \n\nbool find(TreeNode t, int x) {\n\n    if (t == null)\n\n        return false;\n\n    if (t.value == x)\n\n        return true;\n\n    if (x < t.value)\n\n        return find(t.left, x);\n\n    else\n\n        return find(t.right, x);\n\n}\n\nfind(root, x);\n\n\n\nThe described algorithm works correctly if the tree is binary search tree (i.e. for each node the values of left subtree are less than the value in the node, the values of right subtree are greater than the value in the node). But it can return invalid result if tree is not a binary search tree.\n\nSince the given tree is not necessarily a binary search tree, not all numbers can be found this way. Your task is to calculate, how many times the search will fail being running on every value from the tree.\n\nIf the tree has multiple vertices with the same values on them then you should run algorithm on every one of them separately.\n\n\n-----Input-----\n\nFirst line contains integer number n (1 \u2264 n \u2264 10^5) \u2014 number of vertices in the tree.\n\nEach of the next n lines contains 3 numbers v, l, r (0 \u2264 v \u2264 10^9) \u2014 value on current vertex, index of the left child of the vertex and index of the right child of the vertex, respectively. If some child doesn't exist then number  - 1 is set instead. Note that different vertices of the tree may contain the same values.\n\n\n-----Output-----\n\nPrint number of times when search algorithm will fail.\n\n\n-----Examples-----\nInput\n3\n15 -1 -1\n10 1 3\n5 -"], "prompt": "\nQUESTION:\nLet T be arbitrary binary tree \u2014 tree, every vertex of which has no more than two children. Given tree is rooted, so there exists only one vertex which doesn't have a parent \u2014 it's the root of a tree. Every vertex has an integer number written on it. Following algorithm is run on every value from the tree T:  Set pointer to the root of a tree.  Return success if the value in the current vertex is equal to the number you are looking for  Go to the left child of the vertex if the value in the current vertex is greater than the number you are looking for  Go to the right child of the vertex if the value in the current vertex is less than the number you are looking for  Return fail if you try to go to the vertex that doesn't exist \n\nHere is the pseudo-code of the described algorithm: \n\nbool find(TreeNode t, int x) {\n\n    if (t == null)\n\n        return false;\n\n    if (t.value == x)\n\n        return true;\n\n    if (x < t.value)\n\n        return find(t.left, x);\n\n    else\n\n        return find(t.right, x);\n\n}\n\nfind(root, x);\n\n\n\nThe described algorithm works correctly if the tree is binary search tree (i.e. for each node the values of left subtree are less than the value in the node, the values of right subtree are greater than the value in the node). But it can return invalid result if tree is not a binary search tree.\n\nSince the given tree is not necessarily a binary search tree, not all numbers can be found this way. Your task is to calculate, how many times the search will fail being running on every value from the tree.\n\nIf the tree has multiple vertices with the same values on them then you should run algorithm on every one of them separately.\n\n\n-----Input-----\n\nFirst line contains integer number n (1 \u2264 n \u2264 10^5) \u2014 number of vertices in the tree.\n\nEach of the next n lines contains 3 numbers v, l, r (0 \u2264 v \u2264 10^9) \u2014 value on current vertex, index of the left child of the vertex and index of the right child of the vertex, respectively. If some child doesn't exist then number  - 1 is set instead. Note that different vertices of the tree may contain the same values.\n\n\n-----Output-----\n\nPrint number of times when search algorithm will fail.\n\n\n-----Examples-----\nInput\n3\n15 -1 -1\n10 1 3\n5 -1 -1\n\nOutput\n2\n\nInput\n8\n6 2 3\n3 4 5\n12 6 7\n1 -1 8\n4 -1 -1\n5 -1 -1\n14 -1 -1\n2 -1 -1\n\nOutput\n1\n\n\n\n-----Note-----\n\nIn the example the root of the tree in vertex 2. Search of numbers 5 and 15 will return fail because on the first step algorithm will choose the subtree which doesn't contain numbers you are looking for.\nPlease provide the solution as pure code only, without explanations or comments.\n\nANSWER:\n```python\n"}}