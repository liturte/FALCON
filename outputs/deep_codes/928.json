{"928": {"code": ["from bisect import bisect_left, bisect_right\n\nN, K = map(int, input().split())\nA = list(map(int, input().split()))\n\n# Calculate prefix sums\nS = [0] * (N + 1)\nfor i in range(N):\n    S[i + 1] = S[i] + A[i]\n\n# Count the number of prefix sums that satisfy the condition\ncnt = [0] * (N + 1)\nfor i in range(N + 1):\n    cnt[i] = bisect_right(S, K + S[i]) - bisect_left(S, K + S[i])", "from collections import deque\nimport sys\ninput = sys.stdin.readline\n\nN, K = map(int, input().split())\nA = list(map(int, input().split()))\n\nleft = 0\nright = 0\ntotal = 0\nanswer = 0\nq = deque()\n\nwhile True:\n    while right < N and total < K:\n        total += A[right]\n        q.append(A[right])\n        right += 1\n\n    if total < K:\n        break\n\n    while total - sum(q) >= K:\n        q.popleft()\n        left += 1\n\n    answer += len(q)\n    total -=", "from collections import deque\nfrom sys import stdin\n\ndef solve():\n    n, k = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    q = deque()\n    s = c = 0\n    for i in a:\n        q.append(i)\n        s += i\n        while s >= k:\n            c += 1\n            s -= q.popleft()\n    return c\n\nprint(solve())\n\n\nExplanation:\n\nThis problem is a variation of the classic \"subarray sum\" problem, which can be solved using a two-pointer technique or a sliding", "from bisect import bisect_left, bisect_right\n\nN, K = map(int, input().split())\nA = list(map(int, input().split()))\n\n# Calculate prefix sums\nS = [0] * (N + 1)\nfor i in range(N):\n    S[i + 1] = S[i] + A[i]\n\n# Calculate the number of prefix sums that are at least K\ncnt = [0] * (N + 1)\nfor i in range(N + 1):\n    cnt[i] = bisect_right(S, K + S[i])\n\n# Calculate the number of contiguous subsequences", "from collections import deque\n\ndef read_input():\n    N, K = map(int, input().split())\n    A = list(map(int, input().split()))\n    return N, K, A\n\ndef solve(N, K, A):\n    queue = deque([0])\n    total = 0\n    count = 0\n    for i in range(N):\n        total += A[i]\n        while queue and total - A[queue[0]] >= K:\n            queue.popleft()\n        count += len(queue)\n        while queue and total <= A[queue[-1]]:\n            queue.pop()\n        queue.append(i)\n    return"], "prompt": "\nQUESTION:\nYou are given a sequence of positive integers of length N, A=a_1,a_2,\u2026,a_{N}, and an integer K.\nHow many contiguous subsequences of A satisfy the following condition?\n - (Condition) The sum of the elements in the contiguous subsequence is at least K.\nWe consider two contiguous subsequences different if they derive from different positions in A, even if they are the same in content.\nNote that the answer may not fit into a 32-bit integer type.\n\n-----Constraints-----\n - 1 \\leq a_i \\leq 10^5\n - 1 \\leq N \\leq 10^5\n - 1 \\leq K \\leq 10^{10}\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN K\na_1 a_2 ... a_N\n\n-----Output-----\nPrint the number of contiguous subsequences of A that satisfy the condition.\n\n-----Sample Input-----\n4 10\n6 1 2 7\n\n-----Sample Output-----\n2\n\nThe following two contiguous subsequences satisfy the condition:\n - A[1..4]=a_1,a_2,a_3,a_4, with the sum of 16\n - A[2..4]=a_2,a_3,a_4, with the sum of 10\nPlease provide the solution as pure code only, without explanations or comments.\n\nANSWER:\n```python\n"}}