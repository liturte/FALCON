{"667": {"code": ["import sys\n\ndef floyd_warshall(graph):\n    dist = graph\n    for k in range(len(graph)):\n        for i in range(len(graph)):\n            for j in range(len(graph)):\n                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n    return max(map(max, dist))\n\nN = int(sys.stdin.readline())\ngraph = [[int(x) for x in sys.stdin.readline().split()] for _ in range(N)]\nprint(", "import sys\n\ndef floyd_warshall(graph):\n    dist = list(map(lambda i: list(map(lambda j: j, i)), graph))\n    for k in range(len(graph)):\n        for i in range(len(graph)):\n            for j in range(len(graph)):\n                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n    return dist\n\ndef solve():\n    n = int(input())\n    graph = [list(map(int, input().split())) for _ in range(n", "def floyd_warshall(graph):\n    distance_matrix = graph\n    for k in range(len(graph)):\n        for i in range(len(graph)):\n            for j in range(len(graph)):\n                distance_matrix[i][j] = min(distance_matrix[i][j], distance_matrix[i][k] + distance_matrix[k][j])\n    return distance_matrix\n\ndef solve(N, distances):\n    INF = float('inf')\n    graph = [[INF]*N for _ in range(N)]\n    for i in range(N):", "import networkx as nx\n\ndef solve(n, matrix):\n    G = nx.Graph()\n    for i in range(n):\n        for j in range(n):\n            if matrix[i][j] != 0:\n                G.add_edge(i+1, j+1, weight=matrix[i][j])\n    shortest_paths = dict(nx.all_pairs_dijkstra(G))\n    max_path = max([max(paths.values()) for paths in shortest_paths.values()])\n    return max_path\n\nn = int(input", "import sys\nfrom heapq import heappop, heappush\n\ndef dijkstra(graph, start):\n    heap = [(0, start)]\n    distances = [float('inf')] * len(graph)\n    distances[start] = 0\n    while heap:\n        dist, node = heappop(heap)\n        if dist != distances[node]: continue\n        for neighbor, neighbor_dist in graph[node].items():\n            old_dist = distances[neighbor]\n            new_dist = dist + neighbor_dist\n            if new_dist < old_dist:\n                distances[neighbor"], "prompt": "\nQUESTION:\nYou are given a complete undirected graph. For each pair of vertices you are given the length of the edge that connects them. Find the shortest paths between each pair of vertices in the graph and return the length of the longest of them.\n\n\n-----Input-----\n\nThe first line of the input contains a single integer N (3 \u2264 N \u2264 10).\n\nThe following N lines each contain N space-separated integers. jth integer in ith line a_{ij} is the length of the edge that connects vertices i and j. a_{ij} = a_{ji}, a_{ii} = 0, 1 \u2264 a_{ij} \u2264 100 for i \u2260 j.\n\n\n-----Output-----\n\nOutput the maximum length of the shortest path between any pair of vertices in the graph.\n\n\n-----Examples-----\nInput\n3\n0 1 1\n1 0 4\n1 4 0\n\nOutput\n2\n\nInput\n4\n0 1 2 3\n1 0 4 5\n2 4 0 6\n3 5 6 0\n\nOutput\n5\n\n\n\n-----Note-----\n\nYou're running short of keywords, so you can't use some of them:define\n\ndo\n\nfor\n\nforeach\n\nwhile\n\nrepeat\n\nuntil\n\nif\n\nthen\n\nelse\n\nelif\n\nelsif\n\nelseif\n\ncase\n\nswitch\nPlease provide the solution as pure code only, without explanations or comments.\n\nANSWER:\n```python\n"}}