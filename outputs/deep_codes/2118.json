{"2118": {"code": ["QUESTION:\nMerge sort is a well-known sorting algorithm. The main function that sorts the elements of array a with indices from [l, r) can be implemented as follows:  If the segment [l, r) is already sorted in non-descending order (that is, for any i such that l \u2264 i < r - 1 a[i] \u2264 a[i + 1]), then end the function call;  Let $\\operatorname{mid} = \\lfloor \\frac{l + r}{2} \\rfloor$;  Call mergesort(a, l, mid);  Call mergesort(a, mid, r);  Merge segments [l, mid) and [mid, r), making the segment [l, r) sorted in non-descending order. The merge algorithm doesn't call any other functions. \n\nThe array in this problem is 0-indexed, so to sort the whole array, you need to call mergesort(a, 0, n).\n\nThe number of calls of function mergesort is very important, so Ivan has decided to calculate it while sorting the array. For example, if a = {1, 2, 3, 4}, then there will be 1 call of mergesort \u2014 mergesort(0, 4), which will check that the array is sorted and then end. If a = {2, 1, 3}, then the number of calls is 3: first of all, you call mergesort(0, 3), which then sets mid = 1 and calls mergesort(0, 1) and mergesort(1, 3), which do not perform any recursive calls because segments (0, 1) and (1, 3) are sorted.\n\nIvan has implemented the program that counts the number of mergesort calls, but now he needs to test it. To do this, he needs to find an array a such that a is a permutation of size n (that is, the number of elements in a is n, and every integer number from [1, n] can be found in this array), and the number of mergesort calls when sorting the array is exactly k.\n\nHelp Ivan to find an array he wants!\n\n\n-----Input-----\n\nThe first line contains two numbers n and k (1 \u2264 n \u2264 100000, 1 \u2264 k \u2264 200000) \u2014 the size of a desired permutation and the number of mergesort calls required to sort it.\n\n\n-----Output-----\n\nIf a permutation of size n such that there will be", "QUESTION:\nMerge sort is a well-known sorting algorithm. The main function that sorts the elements of array a with indices from [l, r) can be implemented as follows:  If the segment [l, r) is already sorted in non-descending order (that is, for any i such that l \u2264 i < r - 1 a[i] \u2264 a[i + 1]), then end the function call;  Let $\\operatorname{mid} = \\lfloor \\frac{l + r}{2} \\rfloor$;  Call mergesort(a, l, mid);  Call mergesort(a, mid, r);  Merge segments [l, mid) and [mid, r), making the segment [l, r) sorted in non-descending order. The merge algorithm doesn't call any other functions. \n\nThe array in this problem is 0-indexed, so to sort the whole array, you need to call mergesort(a, 0, n).\n\nThe number of calls of function mergesort is very important, so Ivan has decided to calculate it while sorting the array. For example, if a = {1, 2, 3, 4}, then there will be 1 call of mergesort \u2014 mergesort(0, 4), which will check that the array is sorted and then end. If a = {2, 1, 3}, then the number of calls is 3: first of all, you call mergesort(0, 3), which then sets mid = 1 and calls mergesort(0, 1) and mergesort(1, 3), which do not perform any recursive calls because segments (0, 1) and (1, 3) are sorted.\n\nIvan has implemented the program that counts the number of mergesort calls, but now he needs to test it. To do this, he needs to find an array a such that a is a permutation of size n (that is, the number of elements in a is n, and every integer number from [1, n] can be found in this array), and the number of mergesort calls when sorting the array is exactly k.\n\nHelp Ivan to find an array he wants!\n\n\n-----Input-----\n\nThe first line contains two numbers n and k (1 \u2264 n \u2264 100000, 1 \u2264 k \u2264 200000) \u2014 the size of a desired permutation and the number of mergesort calls required to sort it.\n\n\n-----Output-----\n\nIf a permutation of size n such that there will be", "QUESTION:\nMerge sort is a well-known sorting algorithm. The main function that sorts the elements of array a with indices from [l, r) can be implemented as follows:  If the segment [l, r) is already sorted in non-descending order (that is, for any i such that l \u2264 i < r - 1 a[i] \u2264 a[i + 1]), then end the function call;  Let $\\operatorname{mid} = \\lfloor \\frac{l + r}{2} \\rfloor$;  Call mergesort(a, l, mid);  Call mergesort(a, mid, r);  Merge segments [l, mid) and [mid, r), making the segment [l, r) sorted in non-descending order. The merge algorithm doesn't call any other functions. \n\nThe array in this problem is 0-indexed, so to sort the whole array, you need to call mergesort(a, 0, n).\n\nThe number of calls of function mergesort is very important, so Ivan has decided to calculate it while sorting the array. For example, if a = {1, 2, 3, 4}, then there will be 1 call of mergesort \u2014 mergesort(0, 4), which will check that the array is sorted and then end. If a = {2, 1, 3}, then the number of calls is 3: first of all, you call mergesort(0, 3), which then sets mid = 1 and calls mergesort(0, 1) and mergesort(1, 3), which do not perform any recursive calls because segments (0, 1) and (1, 3) are sorted.\n\nIvan has implemented the program that counts the number of mergesort calls, but now he needs to test it. To do this, he needs to find an array a such that a is a permutation of size n (that is, the number of elements in a is n, and every integer number from [1, n] can be found in this array), and the number of mergesort calls when sorting the array is exactly k.\n\nHelp Ivan to find an array he wants!\n\n\n-----Input-----\n\nThe first line contains two numbers n and k (1 \u2264 n \u2264 100000, 1 \u2264 k \u2264 200000) \u2014 the size of a desired permutation and the number of mergesort calls required to sort it.\n\n\n-----Output-----\n\nIf a permutation of size n such that there will be", "QUESTION:\nMerge sort is a well-known sorting algorithm. The main function that sorts the elements of array a with indices from [l, r) can be implemented as follows:  If the segment [l, r) is already sorted in non-descending order (that is, for any i such that l \u2264 i < r - 1 a[i] \u2264 a[i + 1]), then end the function call;  Let $\\operatorname{mid} = \\lfloor \\frac{l + r}{2} \\rfloor$;  Call mergesort(a, l, mid);  Call mergesort(a, mid, r);  Merge segments [l, mid) and [mid, r), making the segment [l, r) sorted in non-descending order. The merge algorithm doesn't call any other functions. \n\nThe array in this problem is 0-indexed, so to sort the whole array, you need to call mergesort(a, 0, n).\n\nThe number of calls of function mergesort is very important, so Ivan has decided to calculate it while sorting the array. For example, if a = {1, 2, 3, 4}, then there will be 1 call of mergesort \u2014 mergesort(0, 4), which will check that the array is sorted and then end. If a = {2, 1, 3}, then the number of calls is 3: first of all, you call mergesort(0, 3), which then sets mid = 1 and calls mergesort(0, 1) and mergesort(1, 3), which do not perform any recursive calls because segments (0, 1) and (1, 3) are sorted.\n\nIvan has implemented the program that counts the number of mergesort calls, but now he needs to test it. To do this, he needs to find an array a such that a is a permutation of size n (that is, the number of elements in a is n, and every integer number from [1, n] can be found in this array), and the number of mergesort calls when sorting the array is exactly k.\n\nHelp Ivan to find an array he wants!\n\n\n-----Input-----\n\nThe first line contains two numbers n and k (1 \u2264 n \u2264 100000, 1 \u2264 k \u2264 200000) \u2014 the size of a desired permutation and the number of mergesort calls required to sort it.\n\n\n-----Output-----\n\nIf a permutation of size n such that there will be", "QUESTION:\nMerge sort is a well-known sorting algorithm. The main function that sorts the elements of array a with indices from [l, r) can be implemented as follows:  If the segment [l, r) is already sorted in non-descending order (that is, for any i such that l \u2264 i < r - 1 a[i] \u2264 a[i + 1]), then end the function call;  Let $\\operatorname{mid} = \\lfloor \\frac{l + r}{2} \\rfloor$;  Call mergesort(a, l, mid);  Call mergesort(a, mid, r);  Merge segments [l, mid) and [mid, r), making the segment [l, r) sorted in non-descending order. The merge algorithm doesn't call any other functions. \n\nThe array in this problem is 0-indexed, so to sort the whole array, you need to call mergesort(a, 0, n).\n\nThe number of calls of function mergesort is very important, so Ivan has decided to calculate it while sorting the array. For example, if a = {1, 2, 3, 4}, then there will be 1 call of mergesort \u2014 mergesort(0, 4), which will check that the array is sorted and then end. If a = {2, 1, 3}, then the number of calls is 3: first of all, you call mergesort(0, 3), which then sets mid = 1 and calls mergesort(0, 1) and mergesort(1, 3), which do not perform any recursive calls because segments (0, 1) and (1, 3) are sorted.\n\nIvan has implemented the program that counts the number of mergesort calls, but now he needs to test it. To do this, he needs to find an array a such that a is a permutation of size n (that is, the number of elements in a is n, and every integer number from [1, n] can be found in this array), and the number of mergesort calls when sorting the array is exactly k.\n\nHelp Ivan to find an array he wants!\n\n\n-----Input-----\n\nThe first line contains two numbers n and k (1 \u2264 n \u2264 100000, 1 \u2264 k \u2264 200000) \u2014 the size of a desired permutation and the number of mergesort calls required to sort it.\n\n\n-----Output-----\n\nIf a permutation of size n such that there will be"], "prompt": "\nQUESTION:\nMerge sort is a well-known sorting algorithm. The main function that sorts the elements of array a with indices from [l, r) can be implemented as follows:  If the segment [l, r) is already sorted in non-descending order (that is, for any i such that l \u2264 i < r - 1 a[i] \u2264 a[i + 1]), then end the function call;  Let $\\operatorname{mid} = \\lfloor \\frac{l + r}{2} \\rfloor$;  Call mergesort(a, l, mid);  Call mergesort(a, mid, r);  Merge segments [l, mid) and [mid, r), making the segment [l, r) sorted in non-descending order. The merge algorithm doesn't call any other functions. \n\nThe array in this problem is 0-indexed, so to sort the whole array, you need to call mergesort(a, 0, n).\n\nThe number of calls of function mergesort is very important, so Ivan has decided to calculate it while sorting the array. For example, if a = {1, 2, 3, 4}, then there will be 1 call of mergesort \u2014 mergesort(0, 4), which will check that the array is sorted and then end. If a = {2, 1, 3}, then the number of calls is 3: first of all, you call mergesort(0, 3), which then sets mid = 1 and calls mergesort(0, 1) and mergesort(1, 3), which do not perform any recursive calls because segments (0, 1) and (1, 3) are sorted.\n\nIvan has implemented the program that counts the number of mergesort calls, but now he needs to test it. To do this, he needs to find an array a such that a is a permutation of size n (that is, the number of elements in a is n, and every integer number from [1, n] can be found in this array), and the number of mergesort calls when sorting the array is exactly k.\n\nHelp Ivan to find an array he wants!\n\n\n-----Input-----\n\nThe first line contains two numbers n and k (1 \u2264 n \u2264 100000, 1 \u2264 k \u2264 200000) \u2014 the size of a desired permutation and the number of mergesort calls required to sort it.\n\n\n-----Output-----\n\nIf a permutation of size n such that there will be exactly k calls of mergesort while sorting it doesn't exist, output  - 1. Otherwise output n integer numbers a[0], a[1], ..., a[n - 1] \u2014 the elements of a permutation that would meet the required conditions. If there are multiple answers, print any of them.\n\n\n-----Examples-----\nInput\n3 3\n\nOutput\n2 1 3 \nInput\n4 1\n\nOutput\n1 2 3 4 \nInput\n5 6\n\nOutput\n-1\nPlease provide the solution as pure code only, without explanations or comments.\n\nANSWER:\n```python\n"}}