{"2000": {"code": ["from collections import defaultdict\n\ndef count_pairs(n, arr):\n    count = defaultdict(int)\n    for num in arr:\n        count[num] += 1\n\n    result = 0\n    for num in count:\n        if num & (num - 1) == 0:  # check if num is power of 2\n            result += count[num] * (count[num] - 1) // 2  # calculate combinations\n\n    return result\n\nn = int(input().strip())\narr = list(map(int, input().strip().split()))\nprint(count_pairs(n, arr))\n\nThe solution uses a dictionary to count the occurrence of each number in the array. Then for each number in the dictionary, if it is a power of 2,", "from collections import defaultdict\n\ndef count_pairs(n, arr):\n    count = defaultdict(int)\n    for num in arr:\n        i = 0\n        while num:\n            count[i] += num & 1\n            num >>= 1\n            i += 1\n    ans = 0\n    for v in count.values():\n        ans += v * (v-1) // 2\n    return ans\n\nn = int(input())\narr = list(map(int, input().split()))\nprint(count_pairs(n, arr))\n\n\nThis solution works by first creating a count dictionary that counts the number of 1s in each bit position of all the numbers in the array. Then it uses the formula for the number of combinations of 2 from n", "from collections import Counter\n\ndef count_pairs(arr):\n    count = Counter(arr)\n    keys = list(count.keys())\n    pairs = 0\n    for key in keys:\n        if count[key] > 1:\n            pairs += count[key]*(count[key]-1)//2\n    return pairs\n\nn = int(input())\narr = list(map(int, input().split()))\n\narr = [bin(i).count('1') for i in arr]\nprint(count_pairs(arr))\n\n\nThis solution works by converting each number to its binary representation and counting the number of 1's in the binary representation. The count of 1's is used as a key to group numbers with the same number of 1's together.", "from collections import defaultdict\n\nn = int(input())\narr = list(map(int, input().split()))\n\n# Calculate the binary representation of each number in the array\nbin_arr = [bin(i)[2:] for i in arr]\n\n# Create a dictionary to store the count of each binary representation\nbin_dict = defaultdict(int)\nfor b in bin_arr:\n    bin_dict[b] += 1\n\n# Calculate the count of pairs of indexes\npairs = 0\nfor count in bin_dict.values():\n    pairs += count*(count-1)//2\n\nprint(pairs)\n\n\nThis solution works by first converting each number in the array to its binary representation. Then it counts the number of times each binary representation appears in the array. The number", "from collections import Counter\n\ndef count_pairs(n, arr):\n    count = Counter(arr)\n    keys = list(count.keys())\n    pairs = 0\n\n    for num in keys:\n        if num % 2 == 0:\n            pairs += count[num//2] * (count[num] - 1)\n        else:\n            pairs += count[num*2]\n\n    return pairs\n\nn = int(input())\narr = list(map(int, input().split()))\n\nprint(count_pairs(n, arr))\n\n\nThis solution works by first counting the occurrences of each number in the input. Then, for each number in the array, it checks if dividing the number by 2 would give an integer (i.e.,"], "prompt": "\nQUESTION:\nYou are given n integers a_1, a_2, ..., a_{n}. Find the number of pairs of indexes i, j (i < j) that a_{i} + a_{j} is a power of 2 (i. e. some integer x exists so that a_{i} + a_{j} = 2^{x}).\n\n\n-----Input-----\n\nThe first line contains the single positive integer n (1 \u2264 n \u2264 10^5) \u2014 the number of integers.\n\nThe second line contains n positive integers a_1, a_2, ..., a_{n} (1 \u2264 a_{i} \u2264 10^9).\n\n\n-----Output-----\n\nPrint the number of pairs of indexes i, j (i < j) that a_{i} + a_{j} is a power of 2.\n\n\n-----Examples-----\nInput\n4\n7 3 2 1\n\nOutput\n2\n\nInput\n3\n1 1 1\n\nOutput\n3\n\n\n\n-----Note-----\n\nIn the first example the following pairs of indexes include in answer: (1, 4) and (2, 4).\n\nIn the second example all pairs of indexes (i, j) (where i < j) include in answer.\nPlease provide the solution as pure code only, without explanations or comments.\n\nANSWER:\n```python\n"}}