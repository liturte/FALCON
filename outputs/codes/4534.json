{"4534": {"code": ["( self,rowIndex: int):=( self,[1 ]( self,] ) return.[ 3 ]].[ 2 ]. append ()( \"c\"], 1,], 1) [1 ], 2[ 3 ]] [ 3 ]2 ]( self,(( self", "A non-negative\u00a0indexini ] :)( self,, rowIndex, rowIndex )rowIndex( ): return.rowIndex ) )(rowIndex ] ), rowIndex ). split () )rowIndex ] )( rowIndex ),).( )).)( )", "= [ ]] if rowIndex >=] if rowIndex >[] : return] )rowIndex: return self.(\"rowIndex\" ] )return=rowIndex ] [ 1] if\"rowIndex\"[ \"rowIndex\" ][ \"rowIndex\" ] =\"rowIndex\" ]]rowIndex ] = 0) for. append ( row]", "A: return self.( self, rowIndex]selfreturn self( self, rowIndex )() : return( self] )rowIndex -1 ] )int ][ 0 ]] [ 1 ]] )[ 1 ]] )] )2 ]]1 ] )[ 1 ]] [ 0 ] []", "a[2,3,3,1,2,3]12,3,3,1,1,1,1,1,1,1,1,1,1,1,1,2,2,3,3,3,1,1,2,3,3,3,4,5,6,7,8,9,9,10,11,12,13,14,15,15", "rowIndex: int:A= self.)) == 0[[. append (. append (] ). append ( 1,)) )(,(] =( )( ) [ 0)]] =rowIndex =0 ] )", "index,k\u00a0where kk\u00a0where k \u2264\u00a033)) ->( self,: #index, #( self,index:=( self, rowIndex ))self.): ## #( self, rowIndex,( self,:) )( self, rowIndex( self,]( self, rowIndex,", ".[] )(0 ]): return [rowIndex ]0 ] ) return[ 0 ] )]]] ) return [(0 ],])(,rowIndex ]. split (),)}=)", "\"0\".)int )#None(( self,rowIndex ]) : return []]], 0, 0, 1,1, 1,)) : return( self,( self)( self, rowIndexreturn [, 1, 0]", "[] :0,(,[ 1,, 2, 3, 3, 3], 2, 3,, 3,,, 3,, 2,, 3,, 3,,,,, 3,2,, 2, 1,"], "prompt": "\nQUESTION:\nGiven a non-negative\u00a0index k\u00a0where k \u2264\u00a033, return the kth\u00a0index row of the Pascal's triangle.\n\nNote that the row index starts from\u00a00.\n\n\nIn Pascal's triangle, each number is the sum of the two numbers directly above it.\n\nExample:\n\n\nInput: 3\nOutput: [1,3,3,1]\n\n\nFollow up:\n\nCould you optimize your algorithm to use only O(k) extra space?\nclass Solution:\n    def getRow(self, rowIndex: int) -> List[int]:\n        \nUse Call-Based format\nANSWER:\n"}}