{"1685": {"code": [".number ofis thein thethe paththeofthe.number of vertices inthethe).( 1(1=().().; if (( 1==)... n ; if (", ". [Image]in a complete binary treeis anumbered from 1 to;1that the paththeof theisof thetheu_{i}is theinthe.[Image] \n\nTnn == 1 andin the1.[Image] \n\nTifto(1 \u2264 n", "1\u2264au_{i} \u2264 n).=2(1\u2264 n), thes_i }is the number ofa0.(1 \u2264is= 4 and s_i}s_i = u_{i} \u2264\u2264s_i(1 \u2264 u_{i} \ufffd", ". [Image]thenumber ofin thethe. [Image] \n\nT=)= 0. ; for= 0 ; i <. length ; i ++= 0 ; i+ 1 ; i1 ; i(= 2= 1 ; i <) ; isuch thatlength is)+ 11n. length ; i0 ;", ". [Image] \n\nTthe. [Image] \n\nT2issuch thatnthatthe(1= 2.(1 \u2264u_{i} \u2264 n,. [Image]'L' and 'R'n.= 2..(1 \u22641).(1 \ufffd", "thethethe0.thatthethethen = 2,. n = n. n;n=. n; if (inin theis= 1.=== 0.= 0.( 1= 2. n = 0.", "n + 1aof the) andit is(1 \u2264 n \u2264)is notthe pathfor a(1\u2264n \u2264 10^18, q)(1 \u2264 n \u2264s_{i} is1.n ==)(1 \u2264 n.),", "thevertex. the; if u_{i} =the2^18, q= 1.1.= 1.u_{i}=s_{i}..n = n +) {.= n.)..)... length, n =", ". [Image] \n\nT2 \u2264n =(1 \u2264\u2264 n ).(1 \u2264 nthe path starting from.1u_{i}..2. n. n. nu_{i} n = 2u_{i}1 \u2264 n,1 )n \u2264", ". [Image]a complete binary tree with1. [Image]a complete binary tree.(1 \u2264 n \u2264) and.a complete binary treethe paththethe0\u2264 nthe number.;thetheis oneisthe result of the[Image] \n\nTtheone of the(1"], "prompt": "\nQUESTION:\nT is a complete binary tree consisting of n vertices. It means that exactly one vertex is a root, and each vertex is either a leaf (and doesn't have children) or an inner node (and has exactly two children). All leaves of a complete binary tree have the same depth (distance from the root). So n is a number such that n + 1 is a power of 2.\n\nIn the picture you can see a complete binary tree with n = 15. [Image] \n\nVertices are numbered from 1 to n in a special recursive way: we recursively assign numbers to all vertices from the left subtree (if current vertex is not a leaf), then assign a number to the current vertex, and then recursively assign numbers to all vertices from the right subtree (if it exists). In the picture vertices are numbered exactly using this algorithm. It is clear that for each size of a complete binary tree exists exactly one way to give numbers to all vertices. This way of numbering is called symmetric.\n\nYou have to write a program that for given n answers q queries to the tree.\n\nEach query consists of an integer number u_{i} (1 \u2264 u_{i} \u2264 n) and a string s_{i}, where u_{i} is the number of vertex, and s_{i} represents the path starting from this vertex. String s_{i} doesn't contain any characters other than 'L', 'R' and 'U', which mean traverse to the left child, to the right child and to the parent, respectively. Characters from s_{i} have to be processed from left to right, considering that u_{i} is the vertex where the path starts. If it's impossible to process a character (for example, to go to the left child of a leaf), then you have to skip it. The answer is the number of vertex where the path represented by s_{i} ends.\n\nFor example, if u_{i} = 4 and s_{i} = \u00abUURL\u00bb, then the answer is 10.\n\n\n-----Input-----\n\nThe first line contains two integer numbers n and q (1 \u2264 n \u2264 10^18, q \u2265 1). n is such that n + 1 is a power of 2.\n\nThe next 2q lines represent queries; each query consists of two consecutive lines. The first of these two lines contains u_{i} (1 \u2264 u_{i} \u2264 n), the second contains non-empty string s_{i}. s_{i} doesn't contain any characters other than 'L', 'R' and 'U'.\n\nIt is guaranteed that the sum of lengths of s_{i} (for each i such that 1 \u2264 i \u2264 q) doesn't exceed 10^5.\n\n\n-----Output-----\n\nPrint q numbers, i-th number must be the answer to the i-th query.\n\n\n-----Example-----\nInput\n15 2\n4\nUURL\n8\nLRLLLLLLLL\n\nOutput\n10\n5\nUse Standard Input format\nANSWER:\n"}}